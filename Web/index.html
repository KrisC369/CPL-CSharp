<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">
    <title>C#</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="An overview by socratic questioning.">
    <meta name="author" content="">

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/shCoreDefault.css" rel="stylesheet">

    <!--[if lt IE 9]>
    <script src="js/html5.js"></script>
    <![endif]-->
</head>

<body>

<div id="wrap">

<div class="container">
<div class="page-header">
    <h1>C# versus Java</h1>

    <p class="lead">A discussion by socratic questioning.</p>
</div>

<p>For the class Gigantic Software Project Development, an assignment for groups of 3 was given to the students.
    The assignment consisted of creating a program for simulating amusements parks, while keeping in mind all of
    the safety regulations and pricing details. The implementation could be done in any programming language of
    choice. However, another part of the assignment was to fully explain why that particular programming
    language was chosen. Moe, Larry and Curley formed a team and started a discussion on which programming
    language they would be using. Bearing in mind that they should have to document exactly why they chose the
    programming language, the discussion got rather long.

</p>

<div id="joke">
    <p><img src="img/joke.jpg" class="img-polaroid"></p>
    <p><small>An example of socratic questioning.</small></p>
</div>

<p>Moe would like to use <strong>C#</strong> as he is quite an
    expert in it. Larry on the other hand, thinks they should stick to <strong>Java</strong> as it is the
    programming
    language they know well by practicing it in other courses during the last 4 years. Curley does not really
    care what programming language is used, as long as the program can be written down easily in it. What
    follows is the discussion, where names in front of a paragraph or question depict who said what.
</p>


<hr class="bs-docs-separator">

<h4>When and why was C# developed?</h4>

<p>In 1972, a programming language called C was designed by Dennis Ritchie and in 1983 it was augmented by
    Bjarne Stroustrup with type checking and classes. This language was named C with Classes and it became
    known, along with some other new features, as C++ in 1984. The Sun Microsystems people in 1990 did not like
    C or C++, so they excluded some of the features like multiple inheritance, pointers, structs, enum types,
    operator overloading and a goto statement. Therefore making it a smaller, a simpler and especially a more
    reliable programming language called Java. Then, in July 2000, Microsoft announced the programming language
    C# because they disagreed with Sun Microsystems about the removal of all those features available in C++,
    except for multiple inheritance. Therefore, C# is very close to C++. It borrows mosts of its statements,
    keywords and operators directly from C++.
</p>

<p>One can thus see C# as an advance over both C++ and Java, because it offers an alternative to the difficult
    C++ programming language but also an alternative for Java programmers who are missing features of C and C++.
    Another reason for the development of C# was to provide a language for component-based software
    development.
</p>

<h4>So, does C# support modularity better than Java?</h4>

<p>An important aspect of software development when talking about modularity is the ability to compartmentalize
    your code and to import different libraries.
    C# provides the functionality of referencing namespaces which are basically scopes for arbitrary sections of
    code. In Java one can import certain classes. The main difference between the using statement from c# and
    the import statement from Java is the fact that you can’t immediately use a single class in c#. You always
    have to use the namespace. To compare this with Java, a namespace looks and behaves more like a Java package
    and the using statement would correspond to the import wildcard in Java. Java imports with wildcards is
    generally frowned upon by the Java community though, as this can lead to unnecessary imports and a less
    clean dependency scheme. If you try to use the using directive on a specific class (say Card) like
    this:
</p>

        <pre class="brush: csharp;">
            using Sorting.Card;
        </pre>

<p>
    the compiler generates the following error: “‘Sorting.Card’ is a type, not a namespace. A using namespace
    directive can only be applied to namespaces.”
    If you want to use the Card class in a C# project, than you would need to import the whole namespace
    Sorting. In java this would correspond to:
</p>

        <pre class="brush: java;">
            import Sorting.*;
        </pre>

<p>while in Java you can alternatively do</p>

        <pre class="brush: java;">
            import Sorting.Card;
        </pre>

<h4>All those preceding languages must have made influences on the C# programming language, haven’t they?</h4>

<p>
    Indeed they did. To give you a concrete example, look at the difference in syntax when implementing an
    interface. In Java you use the implements keyword in your class declaration, because Java was influenced by
    Smalltalk. C# however uses the colon : which is close to the C++ syntax.
</p>

<p>
    Not only are there direct influences from Java and C++, but also from programming languages like Delphi and
    Visual Basic. The former is because the lead designer of C# is Anders Hejlsberg, a Danish software engineer,
    and he is also known for the programming language Delphi. The latter is because Visual Basic is also a .NET
    language.
</p>

<h4>What is C# used for?</h4>

<p>
    C# is used for a variety of software, ranging from command line utilities to phone applications. The latter
    is especially the case with the release of Windows Phone in 2010. Windows Phone is a mobile operation system
    and C# is the most popular programming language to use when building apps for Windows Phone.
</p>

<p>
    C# is also the center language for Windows developers in general. You can make desktop applications with it.
    Here, C# distinguishes between two types of applications: Windows Forms and Windows Presentation Foundation
    (WPF). The latter is newer than the former. Both allow to create controllers like menus and buttons, but the
    latter gives more power and flexibility.
</p>

<p>
    C# can also be used for applications in embedded systems, games and website. The latter can be defined in
    more detail into two categories. The first being the web applications and the second being the web services.
    Web applications can use the ASP.NET technology to create dynamic webpages. Powerful web services can also
    be made with C# to exchange data.
</p>

<p>
    But be aware. C# applications may be intended to be careful with resources such as memory and processing
    power requirements, but the language was not created in order to compete directly, on performance and size,
    with C or an assembly language.
</p>

<h4>Has C# changed since its initial release?</h4>

<p>
    Like any other programming language, C# also evolved over time since its initial release, referred as C#
    1.0, in February 2002. The next version, C# 2.0, was released in November 2005 and includes features like
    generics and nullable types. Two year later, C# 3.0 was released. It mainly added functionality regarding a
    query language called Language Integrated Query (LINQ) for the .NET framework. Other examples of features in
    this update were extension and partial methods. In April 2010, C# 4.0 was released and was focused around
    interoperability. The latest version as of writing, C# 5.0, was released in August 2012 and its main
    features are asynchronous programming and caller information.
</p>

<h4>Are there syntax differences between Java and C#?</h4>

<p>
    What better way to start note some syntactical differences between two programming languages than by writing
    the famous “Hello, World!” program in each of them. In C# we write:
</p>

<pre class="brush: csharp;">
    namespace Hello {
        public class HelloInCSharp
        {
            public static void Main(string[] args)
            {
                System.Console.WriteLine ("Hello, World!");
            }
        }
    }
</pre>

<p>And this the Java equivalent: </p>

<pre class="brush: java;">
    package hello;
    public class HelloInJava
    {
        public static void main(String[] args)
        {
            System.out.println("Hello, World!");
        }
    }
</pre>

<p>
    Wait a minute, are there really noticeable differences? Indeed, C# follows the same syntax as Java, but it
    is a tiny bit different. The class declarations for this example are the same for both C# and Java.
</p>

<p>
    When we have a closer look at the main method, we see an uppercase m for the main method in C#, but a
    lowercase m in Java. Indeed, C# uses UpperCamelCase (also called PascalCase) for method names, while Java
    uses lowerCamelCase.
</p>

<p>
    The next difference is the writing of the string type. Java uses a capital letter while C# does not.
    Actually, one can write the string type in C# with a capital letter, because string is just an alias for
    System.String. Then we have the actual implementation of the main method, where we again see that C# uses
    the UpperCamelCase notation while Java uses lowerCamelCase.
</p>

<p>
    Last but not least, we note the difference between a namespace in C# and package in Java. In Java it is just
    one line of code, while in C# the code within that namespace is surrounded with a block.
</p>

<h4>What does Java have that C# does not? What are the limitations?</h4>

<p>
    A big advantage of Java over C# is that Java is open source. There are a lot of IDEs to write Java code in, and
    lots of them are free as well (e.g. Eclipse). For C#, developers are mostly bound to Microsoft’s Visual Studio,
    which costs more than 600 euros (for the professional version).
</p>

<p>
    Apart from that, the Java virtual machine (JVM) is installed on most of the hardware these days. The JVM is not
    bound to one operating system. Instead, it can be used on Microsoft’s Windows, Mac OS X, and Linux. This also
    contributes to why the group of Java developers is greater than the group of C# developers. When developing programs
    in Java, companies can target larger groups of people than if the program would be developed in C#.
</p>

<h4>If I recall correctly, there was something called the Mono project. Does this not solve the issues of C# not being
    able to run on a machine that has no Microsoft’s Visual Studio?</h4>

<p>
    Indeed, there is an open-source, cross-platform project called the Mono project. Miguel de Icanza from Ximian
    believed that .NET had the potential to increase programmer productivity and began investigating if a linux version
    was feasible. However, the Mono team was not big enough to create a full product. Therefore, the project was made
    open-source and thus free.
</p>

<h4>Does Mono has limitations in comparison to Microsoft’s Visual Studio?</h4>

<p>
    The last release of Mono was Mono 3.0. This release included features from C# 5.0. There are only a few features of
    C# that are not included in Mono. What is missing most are System.Management, which can not be mapped to linux, and
    the async pipeline. The latter needs a parallel processing pipeline with async support. This is not (yet?)
    implemented in Mono.

</p>

<h4>Okay, apart from the business perspective, are there any other Java features and C# limitations?</h4>

<p>
    Another feature of Java is that enumerations are actually full classes. They can implement interfaces, have private
    constructors, have multiple fields of various types, etc. In C#, enumerations are mostly just named integers. They
    cannot implement interfaces. Also, enums in C# cannot be extended and are not typesafe.
</p>

<p>
    Instance initializers, as depicted in the code below, are a handy Java feature that allows a programmer to
    initialize some fields outside a constructor or a method. The only way to accomplish this behavior in C# is by
    creating a private constructor without parameters, which initializes the instances. This is not a good option since
    this cancels out the use of constructors without parameters and if there are a lot of constructors for the class,
    all of them have to call the private constructor. In C#, instances are mostly initialized in a constructor or at the
    variable’s declaration point.
</p>

<pre class="brush: java;">
    private int myInt;
    private double myDouble;
    private char theLetterC;

    {
        myInt = 0;
        myDouble = 3.1415926535;
        theLetterC = ‘c’;
    }
</pre>

<p>
    Also handy for a programmer, are unchecked exceptions. This is a feature that again, is not in C#. Unchecked
    exceptions allow the programmer to forget about catching exceptions in a method. Instead, the programmer can declare
    an unchecked exception in the signature of the method, alerting all methods that call the method that might throw an
    unchecked exception. The other methods have the possibility to surround the method call with a
    try-catch-construction, or also declare an unchecked exception in their signature. In C#, one has to explicitly
    write try-catch statements and check whether exceptions are thrown manually.
</p>

<p>
    Sometimes it might be necessary for a static member to be imported. In C#, this is not possible, though some people
    state it can be done by forging static members from a raw intermediate language. In Java, static imports are allowed
    and used quite often. An example of static members that can be imported quite easily this way, is the Math class in
    Java.
</p>

<p>
    Also, Java offers some nice features that are not in C#. One of these are soft and phantom references, which make
    the life of the garbage collector a bit easier.
</p>

<h4>Stop right there! What are soft and phantom references?</h4>

<p>
    Soft references in Java can be used to implement memory-sensitive caches. An object which is weakly reachable will
    be discarded at the next garbage collection cycle. Soft references can be left as is, and will be discarded when
    memory is needed instead of just at the end of the garbage collection cycle.
</p>

<p>
    Phantom references can be used to perform pre-garbage collection. Objects are phantomly referenced after they are
    finalized. Phantom references get collected in the references queue as other references do, but the phantom
    references can still be used to clean up after finalizations. Phantom references were introduced to replace the
    finalize-construct, which heavily slows down the execution.
</p>

<h4>So why shouldn’t we use Java? What are the advantages of C#?</h4>

<p>
    In some ways, C# code is more compact than Java code. For instance, implementing an interface is done by adding a
    colon between the class and the interface to implement. When implementing an interface or extending a class in Java,
    you use the keyword <code>extends</code> and <code>implements</code>, but in C# you just use a colon. Thus in Java
    one writes <code>Cat extends Animal</code>, but in C# one writes <code>Cat : Animal</code>. C# also allows compact
    getters and setters, whereas Java requires a programmer to fully type the getter and setter methods. Another
    difference is when you write a switch statement in C#, a break is mandatory for each case.
</p>

<p>
    When it comes to conversions, C# has more to show than Java. A programmer is able to use implicit as well as
    explicit conversions in C#. In Java, only explicit conversions are possible. Sometimes, just returning an object
    might not be enough. For this purpose, C# allows a programmer to output parameters to methods. This isn’t possible
    in Java. C# does not require all arguments of a method or function to be used, meaning some can be optional. There
    is no such thing as optional parameters in Java. C# allows more kinds of methods than Java. For instance, there are
    generator methods in C#.
</p>

<p>
    Delegates are also an example of how C# can be more compact than Java. A programmer is allowed to write more public
    classes in one file when using C#. In Java, this is not the case, as the class name must be equal to the file name,
    making it impossible to get two public classes in one file. For this purpose, C# uses different access modifiers
    than Java. Another issue with Java is that one mostly needs to write full method names, whereas in C# the programmer
    is able to overload operators. This can be very handy.
</p>

<h4>
    Woow, that are a lot of differences. I am curious about all of those. Let me go more into detail. What is operator
    overloading exactly and why should you use it?
</h4>

<p>
    The best way to illustrate what operator overloading is and what the benefit is, is by starting with some C# code.
    We have a <code>Matrix</code> class that represents a matrix. We can for example add matrices in mathematics. To
    implement this, we add methods to the <code>Matrix</code> class. Using these methods result in the code below.
</p>

<pre class="brush: csharp;">
Matrix m1,m2;
Matrix result = m1.Add(m2);
</pre>

<p>
    This is ok, but wouldn’t it be more clear if you could write the following line of code instead?
</p>

<pre class="brush: csharp;">
Matrix result = m1 + m2;
</pre>

<p>
    Off course the latter code is preferred as it is more readable and natural. Lets go a bit further. Which one of the
    following lines of code below do you prefer?
</p>

<pre class="brush: csharp;">
Matrix result1 = m1.Add(m2.Add(m3.Add(m4);
Matrix result2 = m1 + m2 + m3 + m4;
</pre>

<p>
    Here again, the latter is preferred because it is easier to work with. We can now start with the real job that is
    operator overloading. Have a closer look at the following example code:
</p>

<pre class="brush: csharp;">
Matrix result3 = m1 + m2;
Matrix result4 = m1 + 5;
</pre>

<p>
    The latter expression could be defined as “add 5 to each element of the matrix”. So here we are overloading the +
    operator with different argument types. We can conclude that operator overloading let us give a new meaning to
    operators.
</p>

<h4>So how does it work in C#? </h4>

<p>
    Indeed, I only showed how you can use it, but not how you implement it. I will continue the previous example. It is
    very straightforward. Just like writing your own methods, you write multiple methods with the same operator, but
    with different argument types and you also use the <code>operator</code> keyword followed by the operator. The
    following lines of code will illustrate this.
</p>

<pre class="brush: csharp;">
class Matrix
{
	// ...

	public static Matrix operator +(Matrix m1, Matrix m2)
	{
		// implementation
		// add m1 and m2
	}

    public static Matrix operator +(Matrix m1, int n)
	{
		// implementation
	// add n to each element in m1
	}
}
</pre>

<p>Like I said, it’s just that simple.</p>

<h4>How does it work in Java?</h4>

<p>
    The answer to this question is very short: it can’t be done. The only thing that comes close to operator overloading
    in Java is the operator <code>+</code>. You can use it to add up two numbers, but you also use it for string
    concatenation like show in the following example code:
</p>

<pre class="brush: java;">
int x = 5 + 5; // adding up two numbers
String result = "x = " + x; // string concatenation
</pre>

<h4>Why isn’t it included in Java?</h4>

<p>
    There are two reasons why the Java people did not include operator overloading. The first and also the main raison
    is the compiler complexity. The second reason was just a personal choice made by James Gosling, the creator of Java
    who believed that adding operator overloading would not comply with the clean mindness of Java.
</p>

<h4>I’ve heard that you can use operator overloading to convert to and from other types, is that correct?</h4>

<p>
    You are correct and it is also very natural like the following example code. Instead of writing the first line of
    code, one can write the second line that does the same thing.
</p>

<pre class="brush: csharp;">
MyStruct myStruct1 = new MyStruct(5);
MyStruct myStruct2 = 5;
</pre>

<p>
    The inverse of this mechanism is the following code, which is also very straightforward to write and understand:
</p>

<pre class="brush: csharp;">
int i = myStruct2;
</pre>

<p>
    As you probably guessed, <code>i</code> will be equal to 5. To implement this, it is the same as in the previous
    question.
</p>

<h4>I do not understand, where does this operator overloading happen?</h4>

<p>
    Well, here the operator overloading is on the <code>=</code> operator. You can see that on the same object type,
    this operator is used on the first line to just assign a value to the variable. On the second line however, it is
    used as a special constructor, like I indicated with colors.
</p>

<h4>I remember you talking about implicit and explicit conversions. What are they actually?</h4>

<p>
    Conversions, whether they are implicit or explicit, are ways of converting an object to an object of a different
    type. Sometimes it happens that a certain function or method expects an object of a certain type, but you only have
    an object of another (albeit similar) type available.
</p>

<p>

    There are two main ways of effecting such a conversion, namely implicitly or explicitly. Explicit conversion is the
    most basic way of converting an object of type A to an object of type B. This is often done by calling a method on
    the first object which returns an object of type B. This example shows how explicit conversion is done in java.
</p>

<pre class="brush: java;">
Double d = new Double(2.0);
double d2 = d.doubleValue();
</pre>

<p>
    Implicit conversions are a bit more subtle than explicit conversions in the way that they occur whenever they need
    to without the programmer actually having to explicitly state the conversion.
</p>

<p>
    The conversion method should just be available in the code somewhere and whenever an object of type A is provided
    where type B is needed, this method is automatically used to perform the conversion, often without the programmer
    noticing. This is a very handy mechanism for keeping the amount of code to write to a minimum when converting
    between types.
</p>

<p>
    But in short, explicit conversion is explicitly telling the program to do a conversion and implicit conversion is
    having the program do it automatically.
</p>

<h4>So Java doesn’t have any form of this implicit conversion?</h4>

<p>
    Well, that’s not exactly true either. Since Java version 1.5, Java does have some form of implicit conversions. To
    be more precise, you can use implicit conversions for the existing java primitives. You can assign objects of type
    Double to double typed variables as shown in the following example.
</p>

<pre class="brush: java;">
Double d = 2.0;
double d2 = d;
</pre>

<p>
    This however only works for java primitives and their associated wrapper-classes. Java does not provide any
    mechanism for declaring your own implicit methods for automated
    conversion between two non-primitive types while C# does.
</p>

<h4>What can you tell me about data types in both languages?</h4>

<p>
    &nbsp;
</p>

<h4>What is the added value of being able to use more primitive/value types?</h4>

<p>
    In java there are a few limited primitive types (int, double, float, boolean,...?). These primitive types differ
    from regular objects in the sense that they are value types and not reference types. Java internally also uses
    specialized versions of arrays for each of the primitive types and also one for object types. Java also has wrapper
    classes for reference types of the same structure (Integer, Double, Float, Boolean,..).
</p>

<p>
    In C# you can create an infinite number of value types which behave more or less like java primitive types do (by
    using ‘struct’). C# also offers auto-boxing/unboxing for all of these value types and makes them derive from Object
    as well, so they can be used interchangeably whenever a reference type is needed (and it will also be boxed when
    needed). C# also has specialized arrays for the “primitive” types, but can extend the enhanced performance to
    Nullable &lt;int&gt; types. This widens the applicability of the value types and as such the opportunities to derive
    performance gains from using them.
</p>

<h4>What is boxing and unboxing exactly? </h4>

<p>
    Boxing is the act of wrapping a value type in an Object type that is managed on the heap. Value types are managed on
    the stack. This allows for more performance during execution, but the tradeoff is that these value types are limited
    in terms of the operations you can perform on them.
</p>

<p>
    Often you need such a value type to behave as a full blown Object. You can box the value type to get an Object. If
    you just need the value type again, you can unbox it.
</p>

<h4>Does boxing/unboxing happen automatically?</h4>

<p>
    In C#, boxing is implicit and unboxing is explicit. This means that boxing happens automatically while unboxing does
    not. Implicit boxing, in an example:
</p>

<pre class="brush: csharp;">
int i = 1;
object o = i;
</pre>

<p>
    and explicit unboxing:
</p>

<pre class="brush: csharp;">
o = 1;
i = (int) o;
</pre>

<p>
    In java, however, both boxing and unboxing happen automatically (from version 1.5 onwards). This feature is called
    autoboxing and unboxing.
</p>

<pre class="brush: java;">
int i = 1;
i = new Integer(5);
Integer i2 = 3;
</pre>

<h4>This goes hand in hand with the access modifiers of the languages. Are there differences in these?</h4>

<p>
    In Java, you have four access modifiers: public (visible for everyone), private (visible from its class), protected
    (visible from its class and subclasses) and package (visible from the package). In C#, there are five access
    modifiers available. Three of them are the same as Java: public, private and protected. The other two are internal,
    where the access is limited to the assembly and protected internal, where the access is limited to the assembly or
    the types deriving from the class.
</p>

<h4>You mentioned something like compact getters. What is this feature? </h4>

<p>
    Compact getters and setters in C# look like the following snippet of code. This concise notation creates a property
    called <code>Firstname</code> and also generates the getters and setters for that private variable.
</p>

<pre class="brush: csharp;">
public string Firstname { get; set; }
</pre>

<h4>Is there a way to do this in Java?</h4>

<p>
    In Java, it is not possible to create such a compact notation because Java does not include properties. There are
    efforts from IDEs (such as Eclipse and Netbeans) to make it easier for programmers by introducing templates or
    generating getters and setters for the programmers. However, in the Java language itself, one has to fully write the
    getter and setter for a variable.
</p>

<h4>These getters and setters encapsulate properties, right? Is there also something like fields? And so, what is the
    difference?</h4>

<p>
    Properties in C# are a mechanism that allow a programmer to keep the fields private. In some class, the following
    lines of code could come from any class. Note that this is the longer version of the compact notation for getters
    and setters.
</p>

<pre class="brush: csharp;">
private string _myField;

public string Firstname {
    get { return _myField; }
    set { _myField = value; }
}
</pre>

<p>
    Properties have come from the object-oriented principles, which state that the internal workings of a class should
    be hidden from the outside world. Fields, however, should always be kept away from the outside world. Properties
    allow programmers to change the way data on an object is accessed without breaking it’s public interface. A major
    difference between the two is that interfaces cannot have fields, but can contain properties.
</p>

<h4>
    So Java only contains fields. Hmm, are there really no properties in Java?
</h4>

<p>
    In Java, the bean properties dictate the “standard pattern” for accessing fields. Methods starting with get, taking
    no arguments and returning a value, are getters. Setters on the other hand, start with set, take a value as an
    argument and return nothing. However, properties themselves are not provided in Java. They are proposed in the Java
    7 release.
</p>

<h4>
    Going over to the methods and their parameters. How does parameter passing look like in C# and Java?
</h4>

<p>
    C# supports two types of parameter passing: pass-by-reference and pass-by-value. Java is a bit more straightforward
    and only supports pass-by-value. It can be a bit difficult to understand, however, that java actually passes
    references. So the references are passed by value. This means that references to objects are passed and the values
    of the objects can be manipulated but the reference to the object can not be altered! At least not outside the
    method. Inside the method you can change the references, but because those references were copied from the original
    and then passed, altering these references will not have any influence on the original references that were passed.
    In this manner Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer
    in the method and change the data that was pointed to. However, you cannot change where that pointer points.
</p>

<p>
    C# goes a bit further. When declaring the <code>ref</code> keyword in front of a reference type parameter you pass
    to a method, the reference itself is copied from the caller to the method parameter. This allows us to change the
    object which is referenced but you can not update the caller variable’s value. There are two restrictions when using
    the <code>ref</code> keyword. First, the caller is required to supply a variable, not a value, as an argument. In so
    doing, the caller explicitly recognizes that the target method could reassign the values of the variables associated
    with any <code>ref</code> parameters it receives. Furthermore, it is necessary to initialize any local variables
    passed as <code>ref</code> because target methods could read data from <code>ref</code> parameters without first
    assigning them.
</p>

<p>
    The developers from C# included the possibility to add some flexibility regarding these restrictions. When you only
    want to write to your <code>ref</code> parameter, you have to pass the <code>out</code> keyword in front of the
    parameter. Then, it does not need to be initialized. The developer of a method may declare one or more
    <code>out</code> parameters in order to get around the restriction that a method may only have one return type.
</p>

<h4>Is there a way to vary the size of the parameter list dynamically?</h4>

<p>
    Yes, this is possible both with C# and Java. They both handle this in a rather similar fashion. C# provides the
    params keyword that enables the number of arguments to vary in the calling code. The variable after the
    <code>params</code> keyword has to be an array and can be handled just like an ordinary array. Instead of this
    keyword, one has to write (...) in front of the dynamically varying parameter list when using Java. Just like C#,
    the Java compiler creates and initializes an array of same-typed values and pass the array’s reference to the target
    method.
</p>

<h4>Can’t you just declare optional parameters in C#? </h4>

<p>
    C# allows parameters in a method call to be named. This means that a programmer can write the following code, and it
    all works fine.
</p>

<pre class="brush: csharp;">
static void Main(string[] args)
{
    // Output: 5
    Console.WriteLine(CalculateSpeed(100,20));

    // Output: 5
    Console.WriteLine(CalculateSpeed(distance: 100,time: 20));
    // Output: 5
    Console.WriteLine(CalculateSpeed(time: 20, distance: 100));
}

static int CalculateSpeed(int distance, int time)
{
    return (distance / time);
}
</pre>

<p>
    So, with these named parameters allow the programmer to switch the parameters if that would be necessary. Not so
    impressive, one would say. But allowing named parameters introduces the power of optional parameters. Because, once
    a parameter is named, the parameter can be set to optional by the programmer, allowing shorter methods. The
    following code should give a concrete example of how optional parameters work in C#. The example also shows that
    when there are more optional parameters, one can be left out without the program crashing.
</p>

<pre class="brush: csharp;">
static void Main(string[] args)
{
    // Output: 5
    Console.WriteLine(CalculateSpeed(100,20,true,true));

    // Output: 5
    Console.WriteLine(CalculateSpeed(distance: 100,time: 20, seconds: true));
    // Output: 5
    Console.WriteLine(CalculateSpeed(time: 20, distance: 100));
}

// boolean ‘seconds’ indicates the time is in seconds.
// If it is false, the time is used as if it is expressed in hours.
// The meters boolean works in the same way.
static int CalculateSpeed(int distance, int time, [boolean meters = true], [boolean seconds = true])
{
    if(! seconds) time = time * 3600;
    if(! meters) distance = distance * 1000;
    return distance / time
}
</pre>

<h4>Is there a way to accomplish this functionality in Java?</h4>

<p>
    In Java, overloading allows to create a feeling of optional parameters. One could create fields with the default
    values of the parameters. Then, two methods can be created: one with the optional value and one without it. The
    method without the optional value should only call the real method, passing through the default field as the
    parameter.
</p>

<h4>Are all methods considered equal in C# and Java, or are there some special methods?</h4>

<p>
    In comparison to Java, C# supports extension methods and generator methods. The former are methods that are added to
    existing types. The advantage of these methods is that no new derived type needs to be created and that the existing
    type does not need recompiling or modifications. Extension methods are created by putting the keyword this before
    the only parameter, which indicates that the method is an extension for the type of the parameter. An example is
    given by the following lines of code.
</p>

<pre class="brush: csharp;">
public static boolean IsNumeric(this string str)
{
    float output;
    return float.TryParse(str, out output);
}

static void Main(string[] args)
{
    string s = “42”;

    // Output: We did it!
    if(s.IsNumeric()) {
        Console.WriteLine(“We did it!”);
    } else {
        Console.WriteLine(“Ohno, what a failure!”);
    }
}
</pre>

<h4>Then, what are generator methods exactly?</h4>

<p>
    A generator method is a routine that can control the iteration behavior of a loop. A generator method actually
    behaves as a complete iterator. In C#, this behavior is established with the <code>yield</code> keyword. This
    keyword should be read as “remember what I just returned, and iterate from this step onwards for the next result”.
    An example is shown in the code below. In this code, the enumerator will first return happy. When called again, sad
    will be returned, and so on.

</p>

<pre class="brush: csharp;">
public class Emotion : IEnumerable&lt;string&gt;
{
    public IEnumerator&lt;string&gt; GetEnumerator()
    {
        yield return “happy”;
        yield return “sad”;
        yield return “confused”;
        yield return “angry”;
    }
}
</pre>

<h4>Does C# make use of header files to define the different methods like C or C++? And what about Java?</h4>

<p>
    C# never separates the implementation from the declaration so there is no header file like in C or implementation
    file like in C++. Declaration and implementation always appear together in the same file. This removes the
    redundancy to separate declaration and implementation, although there is an exception. C# does support a feature
    called “partial methods” in which the method’s defining declaration is separate from its implementation. Java
    follows this same method and avoid this separation.
</p>

<h4>What are these partial methods?</h4>

<p>
    This is something which was added in C# 3.0 and is an extension of the partial classes concept. A partial class is
    just a way to split the implementation over multiple files. Primarily this is useful for tools that are generating
    or modifying code. In this manner, the program can run one part of the class while a developer modifies another
    part. Partial class that belong together have to share a common name and need to declare the <code>partial</code>
    keyword in the class definition.

</p>

<p>
    Partial methods extend this though by allowing a declaration of a method without an implementation. Partial methods
    are only allowed within partial classes! The practical use of partial methods is the same as before. Implementation
    becomes optional as it can be added after compilation in a sister partial class, likely in a separate file.
</p>

<h4>Do you always have to write the fully qualified name when you use a method and structure your file system
    accordingly?</h4>

<p>
    Java actually enforces some conventions for structuring your packages. As such, you actually need to place each
    package in a folder with the same name, following the same structure in your directories as you do in your packages.
</p>

<p>
    C# uses namespaces, but it does not have any notion of this and although many programmers adopt the previously
    discussed style of organising namespaces, the programmer is free to place the namespaces anywhere they want.
    In some situations, it can also make it harder to understand from which physical location you are actually importing
    a namespace.
</p>

<h4>But surely, you can use the Visual Studio IDE to provide such information?</h4>

<p>
    Yes, the Visual Studio IDE can indeed be used in a lot of ways to assist you in developing and to provide you with
    the information that you need at that time. This does create a greater dependency on a certain IDE in order to
    program in a certain language. An IDE can be a huge benefit, but the lack of an IDE shouldn’t be too much of an
    uncomfortable hindrance either. There are still programmers which prefer less full blown graphical editors, such as
    vim or emacs. In short, IDE-dependency is never a good thing, even if the IDE is a splendid one.
</p>

<h4>I see, but can the namespace mechanism actually lead to problems?</h4>

<p>
    Well, yes. When you are importing whole namespaces, it can be troublesome in some situations to actually discern
    which member class you are actually using if a certain class is present in both namespaces. Imagine the case where
    two namespaces exist, <code>namespaceA</code> and <code>namespaceB</code>. Then we have a class <code>ClassC</code>
    present in both <code>namespaceA</code> and <code>namespaceB</code>.
    The following code would lead to an compilation error:
</p>

<pre class="brush: csharp;">
using namespaceA;
using namespaceB;
</pre>

<p>
    If you need a <code>ClassA</code> from <code>namespaceA</code> and a <code>ClassB</code> from
    <code>namespaceB</code>, this could be problematic. In Java you can just import the specific class you want.
</p>

<h4>Is there no way around this?</h4>

<p>
    Well actually, there is. You can use <code>ClassA</code> from <code>namespaceA</code> directly without the using
    statement, if you write it in full each time you use it.
</p>

<pre class="brush: csharp;">
namespaceA.ClassA a : new namespaceA.ClassA();
</pre>

<p>
    But nevertheless this is less compact nor ideal if it is a heavily used class.
</p>

<h4>You said delegates are an advantage in C#. What is this and is there a Java alternative?</h4>

<p>
    Delegates in C# is a mechanism that allows a programmer to use different functions, albeit with the same return type
    and parameter list, in a concise way. First, a delegator function is created which states the return type and
    parameter list. The delegator function, indicated as a parameter, can be used in a normal function. When calling the
    normal function, any function that suffices to the return type and parameter list of the delegator function can be
    supplied.
</p>

<p>
    In Java, real delegates aren’t provided. However, one can create a delegate mechanism with the following snippet of
    code. However, as one can see, this causes difficulties in reading the code (as the names cannot really indicate
    well what the delegated functions do). This does not improve the clarity of the meaning of the code.
</p>

<pre class="brush: java;">
public Interface Delegate {
    public void doSomething(Object... args)
}

public Class myClass {
    public void myMethod(Delegate delegate) {
        // ...
        delegate.doSomething(args);
        // ...
    }

    public static void main(String[] args) {
        // ...
        myClassObject.myMethod(new Delegate() {
            public void doSomething(Object... args) {
                // do something in this method.
            }
        });
        // ...
    }
}
</pre>

<h4>Are there any other mechanisms that provide compactness?</h4>

<p>
    Yes, C# provides another mechanism! It has yet a far more compact syntax for creating a delegate, introduced in C#
    2.0: anonymous methods. C# 3.0 expands this feature with lambda expressions. Lambda expressions are divided into two
    types: statement lambdas and expressions lambdas.
</p>

<h4>I’ve learned a lot about functional programming lately and I think its quite useful in the right circumstances. So
    i’ve been wondering, is functional programming possible in java or C#?</h4>

<p>
    First of all, let’s talk about java. Java in itself has no capabilities for functional programming in the language
    itself. Lambda expressions, closures, first-class functions and all the other fancy functional programming
    mechanisms are absent from basic java versions. Java is, however, planning on introducing lambda expressions in a
    next version of java.
    The best way to try and do some functional programming in java is to use one of the third-party functional
    programming libraries to do the heavy lifting. But you will never be able to get rid of the verbosity of java
    itself, so if you really want clean functional code, java might not be the best option.
</p>

<p>
    C#, on the other hand has already provided some forms of functional programming like lambda expressions. C# also
    provides strongly typed delegates which can be used to almost the same extent as first-class functions can. However,
    even when C# can technically be used to do functional programming, it will never be as easy to use in this matter as
    a pure functional language and doing a lot of functional programming in C# will also quickly become a hassle.
</p>

<h4>Interesting! Can you elaborate a bit more on this?</h4>

<p>
    Statement lambdas consist of a formal parameter list, followed by the lambda operator ‘=>’ and a code block. Some
    syntactic sugar is missing here. These statements do not have a name, which explains the former ‘anonymous methods’
    terminology. Second, the return type is not formally specified. When using the lambda expression, the compiler is
    able to deduct the return type at runtime. Also, the access modifier is omitted, but as the method is no longer an
    accessible member of the containing class there is no need to describe its accessibility. Similarly a static
    modifier would no longer be necessary. At last, it is also possible to omit parameter types if the compiler is able
    to infer the types. This does not always improves the code as it makes the readability harder. As a guideline,
    consider omitting the types when they are obvious to the reader.
</p>

<p>
    Expression lambdas can make this expressions even less verbose. Expressions with only a single return statement can
    be rewritten without explicitly declaring the return keyword. This could avoid extra brackets.
</p>

<h4>So, what can you do with all these lambdas?</h4>

<p>
    Lambdas are a special type of closures and are used to specify local function-valued arguments in calls to other
    methods, like delegates. They can also be used as expression trees.
</p>

<h4>What are expression trees and how are they related to lambda expressions?</h4>

<p>
    Just like a delegate is an object that enables you to pass around a method, is an expression tree an object that
    enables you to pass around the compiler’s analysis of an expression lambda. So, lambda expressions can be converted
    to expression trees and become objects that represent data that describes the lambda expression, not compiled code.
    This way, we can analyze the lambda at execution time!
</p>

<h4>Can you give a practical application of this?</h4>

<p>
    Expression trees make it possible to analyze the lambda at execution time and use that information to construct, for
    example, a query that you can execute on a database. Consider the following example: you want to find all employees
    with a salary above € 2000 in a remote database. This can be done with the following lambda expression.
</p>

</div>
<div id="push"></div>
</div>

<div id="footer">
    <div class="container">
        <p class="muted credit">Tim Ameye, Kristof Coninx, Sander Van Loock and Koen Wellens.</p>
    </div>
</div>

<script src="js/shCore.js"></script>
<script src="js/shBrushCSharp.js"></script>
<script src="js/shBrushJava.js"></script>
<script>
    SyntaxHighlighter.all();
</script>

</body>
</html>
