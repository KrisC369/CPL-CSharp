<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>C#</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="An overview by socratic questioning.">
    <meta name="author" content="Tim Ameye, Kristof Coninx, Sander Van Loock and Koen Wellens">

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/shCoreDefault.css" rel="stylesheet">

    <!--[if lt IE 9]>
    <script src="js/html5.js"></script>
    <![endif]-->
</head>

<body>

<div id="wrap">

<div class="container">
<div class="page-header">
    <h1>C# versus Java</h1>

    <p class="lead">A discussion by socratic questioning.</p>
</div>

<h2>Interview</h2>

<p>For the class Gigantic Software Project Development, an assignment for groups of 3 was given to the students.
    The assignment consisted of creating a program for simulating amusements parks, while keeping in mind all of
    the safety regulations and pricing details. The implementation could be done in any programming language of
    choice. However, another part of the assignment was to fully explain why that particular programming
    language was chosen. Moe, Larry and Curley formed a team and started a discussion on which programming
    language they would be using. Bearing in mind that they should have to document exactly why they chose the
    programming language, the discussion got rather long.

</p>

<div id="joke">
    <p><img src="img/joke.jpg" class="img-polaroid" alt="Why do Java developers wear glasses?"></p>

    <p>
        <small>An example of socratic questioning.</small>
    </p>
</div>

<p>Moe would like to use <strong>C#</strong> as he is quite an
    expert in it. Larry on the other hand, thinks they should stick to <strong>Java</strong> as it is the
    programming
    language they know well by practicing it in other courses during the last 4 years. Curley does not really
    care what programming language is used, as long as the program can be written down easily in it. What
    follows is the discussion, where names in front of a paragraph or question depict who said what.
</p>

<h4>When and why was C# developed?</h4>

<p>In 1972, a programming language called C was designed by Dennis Ritchie and in 1983 it was augmented by
    Bjarne Stroustrup with type checking and classes. This language was named C with Classes and it became
    known, along with some other new features, as C++ in 1984. The Sun Microsystems people in 1990 did not like
    C or C++, so they excluded some of the features like multiple inheritance, pointers, structs, enum types,
    operator overloading and a goto statement. Therefore making it a smaller, a simpler and especially a more
    reliable programming language called Java. Then, in July 2000, Microsoft announced the programming language
    C# because they disagreed with Sun Microsystems about the removal of all those features available in C++,
    except for multiple inheritance. Therefore, C# is very close to C++. It borrows mosts of its statements,
    keywords and operators directly from C++.
</p>

<p>One can thus see C# as an advance over both C++ and Java, because it offers an alternative to the difficult
    C++ programming language but also an alternative for Java programmers who are missing features of C and C++.
    Another reason for the development of C# was to provide a language for component-based software
    development.
</p>

<h4>So, does C# support modularity better than Java?</h4>

<p>An important aspect of software development when talking about modularity is the ability to compartmentalize
    your code and to import different libraries.
    C# provides the functionality of referencing namespaces which are basically scopes for arbitrary sections of
    code. In Java one can import certain classes. The main difference between the using statement from C# and
    the import statement from Java is the fact that you can’t immediately use a single class in C#. You always
    have to use the namespace. To compare this with Java, a namespace looks and behaves more like a Java package
    and the using statement would correspond to the import wildcard in Java. Java imports with wildcards is
    generally frowned upon by the Java community though, as this can lead to unnecessary imports and a less
    clean dependency scheme. If you try to use the using directive on a specific class (say <code>Card</code>) like
    this:
</p>

        <pre class="brush: csharp;">
            using Sorting.Card;
        </pre>

<p>
    the compiler generates the following error: “‘Sorting.Card’ is a type, not a namespace. A using namespace
    directive can only be applied to namespaces.”
    If you want to use the Card class in a C# project, than you would need to import the whole namespace
    Sorting. In Java this would correspond to:
</p>

        <pre class="brush: java;">
            import Sorting.*;
        </pre>

<p>while in Java you can alternatively do</p>

        <pre class="brush: java;">
            import Sorting.Card;
        </pre>

<h4>All those preceding languages must have made influences on the C# programming language, haven’t they?</h4>

<p>
    Indeed they did. To give you a concrete example, look at the difference in syntax when implementing an
    interface. In Java you use the implements keyword in your class declaration, because Java was influenced by
    Smalltalk. C# however uses the colon : which is close to the C++ syntax.
</p>

<p>
    Not only are there direct influences from Java and C++, but also from programming languages like Delphi and
    Visual Basic. The former is because the lead designer of C# is Anders Hejlsberg, a Danish software engineer,
    and he is also known for the programming language Delphi. The latter is because Visual Basic is also a .NET
    language.
</p>

<h4>What is C# used for?</h4>

<p>
    C# is used for a variety of software, ranging from command line utilities to phone applications. The latter
    is especially the case with the release of Windows Phone in 2010. Windows Phone is a mobile operation system
    and C# is the most popular programming language to use when building apps for Windows Phone.
</p>

<p>
    C# is also the center language for Windows developers in general. You can make desktop applications with it.
    Here, C# distinguishes between two types of applications: Windows Forms and Windows Presentation Foundation
    (WPF). The latter is newer than the former. Both allow to create controllers like menus and buttons, but the
    latter gives more power and flexibility.
</p>

<p>
    C# can also be used for applications in embedded systems, games and website. The latter can be defined in
    more detail into two categories. The first being the web applications and the second being the web services.
    Web applications can use the ASP.NET technology to create dynamic webpages. Powerful web services can also
    be made with C# to exchange data.
</p>

<p>
    But be aware. C# applications may be intended to be careful with resources such as memory and processing
    power requirements, but the language was not created in order to compete directly, on performance and size,
    with C or an assembly language.
</p>

<h4>Has C# changed since its initial release?</h4>

<p>
    Like any other programming language, C# also evolved over time since its initial release, referred as C#
    1.0, in February 2002. The next version, C# 2.0, was released in November 2005 and includes features like
    generics and nullable types. Two year later, C# 3.0 was released. It mainly added functionality regarding a
    query language called Language Integrated Query (LINQ) for the .NET framework. Other examples of features in
    this update were extension and partial methods. In April 2010, C# 4.0 was released and was focused around
    interoperability. The latest version as of writing, C# 5.0, was released in August 2012 and its main
    features are asynchronous programming and caller information.
</p>

<h4>Are there syntax differences between Java and C#?</h4>

<p>
    What better way to start note some syntactical differences between two programming languages than by writing
    the famous “Hello, World!” program in each of them. In C# we write:
</p>

<pre class="brush: csharp;">
    namespace Hello {
        public class HelloInCSharp
        {
            public static void Main(string[] args)
            {
                System.Console.WriteLine ("Hello, World!");
            }
        }
    }
</pre>

<p>And this the Java equivalent: </p>

<pre class="brush: java;">
    package hello;
    public class HelloInJava
    {
        public static void main(String[] args)
        {
            System.out.println("Hello, World!");
        }
    }
</pre>

<p>
    Wait a minute, are there really noticeable differences? Indeed, C# follows the same syntax as Java, but it
    is a tiny bit different. The class declarations for this example are the same for both C# and Java.
</p>

<p>
    When we have a closer look at the main method, we see an uppercase m for the main method in C#, but a
    lowercase m in Java. Indeed, C# uses UpperCamelCase (also called PascalCase) for method names, while Java
    uses lowerCamelCase.
</p>

<p>
    The next difference is the writing of the string type. Java uses a capital letter while C# does not.
    Actually, one can write the string type in C# with a capital letter, because string is just an alias for
    System.String. Then we have the actual implementation of the main method, where we again see that C# uses
    the UpperCamelCase notation while Java uses lowerCamelCase.
</p>

<p>
    Last but not least, we note the difference between a namespace in C# and package in Java. In Java it is just
    one line of code, while in C# the code within that namespace is surrounded with a block.
</p>

<h4>What does Java have that C# does not? What are the limitations?</h4>

<p>
    A big advantage of Java over C# is that Java is open source. There are a lot of IDEs to write Java code in, and
    lots of them are free as well (e.g. Eclipse). For C#, developers are mostly bound to Microsoft’s Visual Studio,
    which costs more than 600 euros (for the professional version).
</p>

<p>
    Apart from that, the Java virtual machine (JVM) is installed on most of the hardware these days. The JVM is not
    bound to one operating system. Instead, it can be used on Microsoft’s Windows, Mac OS X, and Linux. This also
    contributes to why the group of Java developers is greater than the group of C# developers. When developing programs
    in Java, companies can target larger groups of people than if the program would be developed in C#.
</p>

<h4>If I recall correctly, there was something called the Mono project. Does this not solve the issues of C# not being
    able to run on a machine that has no Microsoft’s Visual Studio?</h4>

<p>
    Indeed, there is an open-source, cross-platform project called the Mono project. Miguel de Icanza from Ximian
    believed that .NET had the potential to increase programmer productivity and began investigating if a linux version
    was feasible. However, the Mono team was not big enough to create a full product. Therefore, the project was made
    open-source and thus free.
</p>

<h4>Does Mono has limitations in comparison to Microsoft’s Visual Studio?</h4>

<p>
    The last release of Mono was Mono 3.0. This release included features from C# 5.0. There are only a few features of
    C# that are not included in Mono. What is missing most are System.Management, which can not be mapped to linux, and
    the async pipeline. The latter needs a parallel processing pipeline with async support. This is not (yet?)
    implemented in Mono.

</p>

<h4>Okay, apart from the business perspective, are there any other Java features and C# limitations?</h4>

<p>
    Another feature of Java is that enumerations are actually full classes. They can implement interfaces, have private
    constructors, have multiple fields of various types, etc. In C#, enumerations are mostly just named integers. They
    cannot implement interfaces. Also, enums in C# cannot be extended and are not typesafe.
</p>

<p>
    Instance initializers, as depicted in the code below, are a handy Java feature that allows a programmer to
    initialize some fields outside a constructor or a method. The only way to accomplish this behavior in C# is by
    creating a private constructor without parameters, which initializes the instances. This is not a good option since
    this cancels out the use of constructors without parameters and if there are a lot of constructors for the class,
    all of them have to call the private constructor. In C#, instances are mostly initialized in a constructor or at the
    variable’s declaration point.
</p>

<pre class="brush: java;">
    private int myInt;
    private double myDouble;
    private char theLetterC;

    {
        myInt = 0;
        myDouble = 3.1415926535;
        theLetterC = ‘c’;
    }
</pre>

<p>
    Also handy for a programmer, are unchecked exceptions. This is a feature that again, is not in C#. Unchecked
    exceptions allow the programmer to forget about catching exceptions in a method. Instead, the programmer can declare
    an unchecked exception in the signature of the method, alerting all methods that call the method that might throw an
    unchecked exception. The other methods have the possibility to surround the method call with a
    try-catch-construction, or also declare an unchecked exception in their signature. In C#, one has to explicitly
    write try-catch statements and check whether exceptions are thrown manually.
</p>

<p>
    Sometimes it might be necessary for a static member to be imported. In C#, this is not possible, though some people
    state it can be done by forging static members from a raw intermediate language. In Java, static imports are allowed
    and used quite often. An example of static members that can be imported quite easily this way, is the Math class in
    Java.
</p>

<p>
    Also, Java offers some nice features that are not in C#. One of these are soft and phantom references, which make
    the life of the garbage collector a bit easier.
</p>

<h4>Stop right there! What are soft and phantom references?</h4>

<p>
    Soft references in Java can be used to implement memory-sensitive caches. An object which is weakly reachable will
    be discarded at the next garbage collection cycle. Soft references can be left as is, and will be discarded when
    memory is needed instead of just at the end of the garbage collection cycle.
</p>

<p>
    Phantom references can be used to perform pre-garbage collection. Objects are phantomly referenced after they are
    finalized. Phantom references get collected in the references queue as other references do, but the phantom
    references can still be used to clean up after finalizations. Phantom references were introduced to replace the
    finalize-construct, which heavily slows down the execution.
</p>

<h4>So why shouldn’t we use Java? What are the advantages of C#?</h4>

<p>
    In some ways, C# code is more compact than Java code. For instance, implementing an interface is done by adding a
    colon between the class and the interface to implement. When implementing an interface or extending a class in Java,
    you use the keyword <code>extends</code> and <code>implements</code>, but in C# you just use a colon. Thus in Java
    one writes <code>Cat extends Animal</code>, but in C# one writes <code>Cat : Animal</code>. C# also allows compact
    getters and setters, whereas Java requires a programmer to fully type the getter and setter methods. Another
    difference is when you write a switch statement in C#, a break is mandatory for each case.
</p>

<p>
    When it comes to conversions, C# has more to show than Java. A programmer is able to use implicit as well as
    explicit conversions in C#. In Java, only explicit conversions are possible. Sometimes, just returning an object
    might not be enough. For this purpose, C# allows a programmer to output parameters to methods. This isn’t possible
    in Java. C# does not require all arguments of a method or function to be used, meaning some can be optional. There
    is no such thing as optional parameters in Java. C# allows more kinds of methods than Java. For instance, there are
    generator methods in C#.
</p>

<p>
    Delegates are also an example of how C# can be more compact than Java. A programmer is allowed to write more public
    classes in one file when using C#. In Java, this is not the case, as the class name must be equal to the file name,
    making it impossible to get two public classes in one file. For this purpose, C# uses different access modifiers
    than Java. Another issue with Java is that one mostly needs to write full method names, whereas in C# the programmer
    is able to overload operators. This can be very handy.
</p>

<h4>
    Woow, that are a lot of differences. I am curious about all of those. Let me go more into detail. What is operator
    overloading exactly and why should you use it?
</h4>

<p>
    The best way to illustrate what operator overloading is and what the benefit is, is by starting with some C# code.
    We have a <code>Matrix</code> class that represents a matrix. We can for example add matrices in mathematics. To
    implement this, we add methods to the <code>Matrix</code> class. Using these methods result in the code below.
</p>

<pre class="brush: csharp;">
Matrix m1,m2;
Matrix result = m1.Add(m2);
</pre>

<p>
    This is ok, but wouldn’t it be more clear if you could write the following line of code instead?
</p>

<pre class="brush: csharp;">
Matrix result = m1 + m2;
</pre>

<p>
    Off course the latter code is preferred as it is more readable and natural. Lets go a bit further. Which one of the
    following lines of code below do you prefer?
</p>

<pre class="brush: csharp;">
Matrix result1 = m1.Add(m2.Add(m3.Add(m4);
Matrix result2 = m1 + m2 + m3 + m4;
</pre>

<p>
    Here again, the latter is preferred because it is easier to work with. We can now start with the real job that is
    operator overloading. Have a closer look at the following example code:
</p>

<pre class="brush: csharp;">
Matrix result3 = m1 + m2;
Matrix result4 = m1 + 5;
</pre>

<p>
    The latter expression could be defined as “add 5 to each element of the matrix”. So here we are overloading the +
    operator with different argument types. We can conclude that operator overloading let us give a new meaning to
    operators.
</p>

<h4>So how does it work in C#? </h4>

<p>
    Indeed, I only showed how you can use it, but not how you implement it. I will continue the previous example. It is
    very straightforward. Just like writing your own methods, you write multiple methods with the same operator, but
    with different argument types and you also use the <code>operator</code> keyword followed by the operator. The
    following lines of code will illustrate this.
</p>

<pre class="brush: csharp;">
class Matrix
{
	// ...

	public static Matrix operator +(Matrix m1, Matrix m2)
	{
		// implementation
		// add m1 and m2
	}

    public static Matrix operator +(Matrix m1, int n)
	{
		// implementation
	// add n to each element in m1
	}
}
</pre>

<p>Like I said, it’s just that simple.</p>

<h4>How does it work in Java?</h4>

<p>
    The answer to this question is very short: it can’t be done. The only thing that comes close to operator overloading
    in Java is the operator <code>+</code>. You can use it to add up two numbers, but you also use it for string
    concatenation like show in the following example code:
</p>

<pre class="brush: java;">
int x = 5 + 5; // adding up two numbers
String result = "x = " + x; // string concatenation
</pre>

<h4>Why isn’t it included in Java?</h4>

<p>
    There are two reasons why the Java people did not include operator overloading. The first and also the main raison
    is the compiler complexity. The second reason was just a personal choice made by James Gosling, the creator of Java
    who believed that adding operator overloading would not comply with the clean mindness of Java.
</p>

<h4>I’ve heard that you can use operator overloading to convert to and from other types, is that correct?</h4>

<p>
    You are correct and it is also very natural like the following example code. Instead of writing the first line of
    code, one can write the second line that does the same thing.
</p>

<pre class="brush: csharp;">
MyStruct myStruct1 = new MyStruct(5);
MyStruct myStruct2 = 5;
</pre>

<p>
    The inverse of this mechanism is the following code, which is also very straightforward to write and understand:
</p>

<pre class="brush: csharp;">
int i = myStruct2;
</pre>

<p>
    As you probably guessed, <code>i</code> will be equal to 5. To implement this, it is the same as in the previous
    question.
</p>

<h4>I do not understand, where does this operator overloading happen?</h4>

<p>
    Well, here the operator overloading is on the <code>=</code> operator. You can see that on the same object type,
    this operator is used on the first line to just assign a value to the variable. On the second line however, it is
    used as a special constructor, like I indicated with colors.
</p>

<h4>I remember you talking about implicit and explicit conversions. What are they actually?</h4>

<p>
    Conversions, whether they are implicit or explicit, are ways of converting an object to an object of a different
    type. Sometimes it happens that a certain function or method expects an object of a certain type, but you only have
    an object of another (albeit similar) type available.
</p>

<p>

    There are two main ways of effecting such a conversion, namely implicitly or explicitly. Explicit conversion is the
    most basic way of converting an object of type A to an object of type B. This is often done by calling a method on
    the first object which returns an object of type B. This example shows how explicit conversion is done in Java.
</p>

<pre class="brush: java;">
Double d = new Double(2.0);
double d2 = d.doubleValue();
</pre>

<p>
    Implicit conversions are a bit more subtle than explicit conversions in the way that they occur whenever they need
    to without the programmer actually having to explicitly state the conversion.
</p>

<p>
    The conversion method should just be available in the code somewhere and whenever an object of type A is provided
    where type B is needed, this method is automatically used to perform the conversion, often without the programmer
    noticing. This is a very handy mechanism for keeping the amount of code to write to a minimum when converting
    between types.
</p>

<p>
    But in short, explicit conversion is explicitly telling the program to do a conversion and implicit conversion is
    having the program do it automatically.
</p>

<h4>So Java doesn’t have any form of this implicit conversion?</h4>

<p>
    Well, that’s not exactly true either. Since Java version 1.5, Java does have some form of implicit conversions. To
    be more precise, you can use implicit conversions for the existing Java primitives. You can assign objects of type
    Double to double typed variables as shown in the following example.
</p>

<pre class="brush: java;">
Double d = 2.0;
double d2 = d;
</pre>

<p>
    This however only works for Java primitives and their associated wrapper-classes. Java does not provide any
    mechanism for declaring your own implicit methods for automated
    conversion between two non-primitive types while C# does.
</p>

<h4>What can you tell me about data types in both languages?</h4>

<p>
    &nbsp;
</p>

<h4>What is the added value of being able to use more primitive/value types?</h4>

<p>
    In Java there are a few limited primitive types (int, double, float, boolean,...?). These primitive types differ
    from regular objects in the sense that they are value types and not reference types. Java internally also uses
    specialized versions of arrays for each of the primitive types and also one for object types. Java also has wrapper
    classes for reference types of the same structure (Integer, Double, Float, Boolean,..).
</p>

<p>
    In C# you can create an infinite number of value types which behave more or less like Java primitive types do (by
    using ‘struct’). C# also offers auto-boxing/unboxing for all of these value types and makes them derive from Object
    as well, so they can be used interchangeably whenever a reference type is needed (and it will also be boxed when
    needed). C# also has specialized arrays for the “primitive” types, but can extend the enhanced performance to
    Nullable &lt;int&gt; types. This widens the applicability of the value types and as such the opportunities to derive
    performance gains from using them.
</p>

<h4>What is boxing and unboxing exactly? </h4>

<p>
    Boxing is the act of wrapping a value type in an Object type that is managed on the heap. Value types are managed on
    the stack. This allows for more performance during execution, but the tradeoff is that these value types are limited
    in terms of the operations you can perform on them.
</p>

<p>
    Often you need such a value type to behave as a full blown Object. You can box the value type to get an Object. If
    you just need the value type again, you can unbox it.
</p>

<h4>Does boxing/unboxing happen automatically?</h4>

<p>
    In C#, boxing is implicit and unboxing is explicit. This means that boxing happens automatically while unboxing does
    not. Implicit boxing, in an example:
</p>

<pre class="brush: csharp;">
int i = 1;
object o = i;
</pre>

<p>
    and explicit unboxing:
</p>

<pre class="brush: csharp;">
o = 1;
i = (int) o;
</pre>

<p>
    In Java, however, both boxing and unboxing happen automatically (from version 1.5 onwards). This feature is called
    autoboxing and unboxing.
</p>

<pre class="brush: java;">
int i = 1;
i = new Integer(5);
Integer i2 = 3;
</pre>

<h4>This goes hand in hand with the access modifiers of the languages. Are there differences in these?</h4>

<p>
    In Java, you have four access modifiers: public (visible for everyone), private (visible from its class), protected
    (visible from its class and subclasses) and package (visible from the package). In C#, there are five access
    modifiers available. Three of them are the same as Java: public, private and protected. The other two are internal,
    where the access is limited to the assembly and protected internal, where the access is limited to the assembly or
    the types deriving from the class.
</p>

<h4>You mentioned something like compact getters. What is this feature? </h4>

<p>
    Compact getters and setters in C# look like the following snippet of code. This concise notation creates a property
    called <code>Firstname</code> and also generates the getters and setters for that private variable.
</p>

<pre class="brush: csharp;">
public string Firstname { get; set; }
</pre>

<h4>Is there a way to do this in Java?</h4>

<p>
    In Java, it is not possible to create such a compact notation because Java does not include properties. There are
    efforts from IDEs (such as Eclipse and Netbeans) to make it easier for programmers by introducing templates or
    generating getters and setters for the programmers. However, in the Java language itself, one has to fully write the
    getter and setter for a variable.
</p>

<h4>These getters and setters encapsulate properties, right? Is there also something like fields? And so, what is the
    difference?</h4>

<p>
    Properties in C# are a mechanism that allow a programmer to keep the fields private. In some class, the following
    lines of code could come from any class. Note that this is the longer version of the compact notation for getters
    and setters.
</p>

<pre class="brush: csharp;">
private string _myField;

public string Firstname {
    get { return _myField; }
    set { _myField = value; }
}
</pre>

<p>
    Properties have come from the object-oriented principles, which state that the internal workings of a class should
    be hidden from the outside world. Fields, however, should always be kept away from the outside world. Properties
    allow programmers to change the way data on an object is accessed without breaking it’s public interface. A major
    difference between the two is that interfaces cannot have fields, but can contain properties.
</p>

<h4>
    So Java only contains fields. Hmm, are there really no properties in Java?
</h4>

<p>
    In Java, the bean properties dictate the “standard pattern” for accessing fields. Methods starting with get, taking
    no arguments and returning a value, are getters. Setters on the other hand, start with set, take a value as an
    argument and return nothing. However, properties themselves are not provided in Java. They are proposed in the Java
    7 release.
</p>

<h4>
    Going over to the methods and their parameters. How does parameter passing look like in C# and Java?
</h4>

<p>
    C# supports two types of parameter passing: pass-by-reference and pass-by-value. Java is a bit more straightforward
    and only supports pass-by-value. It can be a bit difficult to understand, however, that Java actually passes
    references. So the references are passed by value. This means that references to objects are passed and the values
    of the objects can be manipulated but the reference to the object can not be altered! At least not outside the
    method. Inside the method you can change the references, but because those references were copied from the original
    and then passed, altering these references will not have any influence on the original references that were passed.
    In this manner Java works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer
    in the method and change the data that was pointed to. However, you cannot change where that pointer points.
</p>

<p>
    C# goes a bit further. When declaring the <code>ref</code> keyword in front of a reference type parameter you pass
    to a method, the reference itself is copied from the caller to the method parameter. This allows us to change the
    object which is referenced but you can not update the caller variable’s value. There are two restrictions when using
    the <code>ref</code> keyword. First, the caller is required to supply a variable, not a value, as an argument. In so
    doing, the caller explicitly recognizes that the target method could reassign the values of the variables associated
    with any <code>ref</code> parameters it receives. Furthermore, it is necessary to initialize any local variables
    passed as <code>ref</code> because target methods could read data from <code>ref</code> parameters without first
    assigning them.
</p>

<p>
    The developers from C# included the possibility to add some flexibility regarding these restrictions. When you only
    want to write to your <code>ref</code> parameter, you have to pass the <code>out</code> keyword in front of the
    parameter. Then, it does not need to be initialized. The developer of a method may declare one or more
    <code>out</code> parameters in order to get around the restriction that a method may only have one return type.
</p>

<h4>Is there a way to vary the size of the parameter list dynamically?</h4>

<p>
    Yes, this is possible both with C# and Java. They both handle this in a rather similar fashion. C# provides the
    params keyword that enables the number of arguments to vary in the calling code. The variable after the
    <code>params</code> keyword has to be an array and can be handled just like an ordinary array. Instead of this
    keyword, one has to write (...) in front of the dynamically varying parameter list when using Java. Just like C#,
    the Java compiler creates and initializes an array of same-typed values and pass the array’s reference to the target
    method.
</p>

<h4>Can’t you just declare optional parameters in C#? </h4>

<p>
    C# allows parameters in a method call to be named. This means that a programmer can write the following code, and it
    all works fine.
</p>

<pre class="brush: csharp;">
static void Main(string[] args)
{
    // Output: 5
    Console.WriteLine(CalculateSpeed(100,20));

    // Output: 5
    Console.WriteLine(CalculateSpeed(distance: 100,time: 20));
    // Output: 5
    Console.WriteLine(CalculateSpeed(time: 20, distance: 100));
}

static int CalculateSpeed(int distance, int time)
{
    return (distance / time);
}
</pre>

<p>
    So, with these named parameters allow the programmer to switch the parameters if that would be necessary. Not so
    impressive, one would say. But allowing named parameters introduces the power of optional parameters. Because, once
    a parameter is named, the parameter can be set to optional by the programmer, allowing shorter methods. The
    following code should give a concrete example of how optional parameters work in C#. The example also shows that
    when there are more optional parameters, one can be left out without the program crashing.
</p>

<pre class="brush: csharp;">
static void Main(string[] args)
{
    // Output: 5
    Console.WriteLine(CalculateSpeed(100,20,true,true));

    // Output: 5
    Console.WriteLine(CalculateSpeed(distance: 100,time: 20, seconds: true));
    // Output: 5
    Console.WriteLine(CalculateSpeed(time: 20, distance: 100));
}

// boolean ‘seconds’ indicates the time is in seconds.
// If it is false, the time is used as if it is expressed in hours.
// The meters boolean works in the same way.
static int CalculateSpeed(int distance, int time, [boolean meters = true], [boolean seconds = true])
{
    if(! seconds) time = time * 3600;
    if(! meters) distance = distance * 1000;
    return distance / time
}
</pre>

<h4>Is there a way to accomplish this functionality in Java?</h4>

<p>
    In Java, overloading allows to create a feeling of optional parameters. One could create fields with the default
    values of the parameters. Then, two methods can be created: one with the optional value and one without it. The
    method without the optional value should only call the real method, passing through the default field as the
    parameter.
</p>

<h4>Are all methods considered equal in C# and Java, or are there some special methods?</h4>

<p>
    In comparison to Java, C# supports extension methods and generator methods. The former are methods that are added to
    existing types. The advantage of these methods is that no new derived type needs to be created and that the existing
    type does not need recompiling or modifications. Extension methods are created by putting the keyword this before
    the only parameter, which indicates that the method is an extension for the type of the parameter. An example is
    given by the following lines of code.
</p>

<pre class="brush: csharp;">
public static boolean IsNumeric(this string str)
{
    float output;
    return float.TryParse(str, out output);
}

static void Main(string[] args)
{
    string s = “42”;

    // Output: We did it!
    if(s.IsNumeric()) {
        Console.WriteLine(“We did it!”);
    } else {
        Console.WriteLine(“Ohno, what a failure!”);
    }
}
</pre>

<h4>Then, what are generator methods exactly?</h4>

<p>
    A generator method is a routine that can control the iteration behavior of a loop. A generator method actually
    behaves as a complete iterator. In C#, this behavior is established with the <code>yield</code> keyword. This
    keyword should be read as “remember what I just returned, and iterate from this step onwards for the next result”.
    An example is shown in the code below. In this code, the enumerator will first return happy. When called again, sad
    will be returned, and so on.

</p>

<pre class="brush: csharp;">
public class Emotion : IEnumerable&lt;string&gt;
{
    public IEnumerator&lt;string&gt; GetEnumerator()
    {
        yield return “happy”;
        yield return “sad”;
        yield return “confused”;
        yield return “angry”;
    }
}
</pre>

<h4>Does C# make use of header files to define the different methods like C or C++? And what about Java?</h4>

<p>
    C# never separates the implementation from the declaration so there is no header file like in C or implementation
    file like in C++. Declaration and implementation always appear together in the same file. This removes the
    redundancy to separate declaration and implementation, although there is an exception. C# does support a feature
    called “partial methods” in which the method’s defining declaration is separate from its implementation. Java
    follows this same method and avoid this separation.
</p>

<h4>What are these partial methods?</h4>

<p>
    This is something which was added in C# 3.0 and is an extension of the partial classes concept. A partial class is
    just a way to split the implementation over multiple files. Primarily this is useful for tools that are generating
    or modifying code. In this manner, the program can run one part of the class while a developer modifies another
    part. Partial class that belong together have to share a common name and need to declare the <code>partial</code>
    keyword in the class definition.

</p>

<p>
    Partial methods extend this though by allowing a declaration of a method without an implementation. Partial methods
    are only allowed within partial classes! The practical use of partial methods is the same as before. Implementation
    becomes optional as it can be added after compilation in a sister partial class, likely in a separate file.
</p>

<h4>Do you always have to write the fully qualified name when you use a method and structure your file system
    accordingly?</h4>

<p>
    Java actually enforces some conventions for structuring your packages. As such, you actually need to place each
    package in a folder with the same name, following the same structure in your directories as you do in your packages.
</p>

<p>
    C# uses namespaces, but it does not have any notion of this and although many programmers adopt the previously
    discussed style of organising namespaces, the programmer is free to place the namespaces anywhere they want.
    In some situations, it can also make it harder to understand from which physical location you are actually importing
    a namespace.
</p>

<h4>But surely, you can use the Visual Studio IDE to provide such information?</h4>

<p>
    Yes, the Visual Studio IDE can indeed be used in a lot of ways to assist you in developing and to provide you with
    the information that you need at that time. This does create a greater dependency on a certain IDE in order to
    program in a certain language. An IDE can be a huge benefit, but the lack of an IDE shouldn’t be too much of an
    uncomfortable hindrance either. There are still programmers which prefer less full blown graphical editors, such as
    vim or emacs. In short, IDE-dependency is never a good thing, even if the IDE is a splendid one.
</p>

<h4>I see, but can the namespace mechanism actually lead to problems?</h4>

<p>
    Well, yes. When you are importing whole namespaces, it can be troublesome in some situations to actually discern
    which member class you are actually using if a certain class is present in both namespaces. Imagine the case where
    two namespaces exist, <code>namespaceA</code> and <code>namespaceB</code>. Then we have a class <code>ClassC</code>
    present in both <code>namespaceA</code> and <code>namespaceB</code>.
    The following code would lead to an compilation error:
</p>

<pre class="brush: csharp;">
using namespaceA;
using namespaceB;
</pre>

<p>
    If you need a <code>ClassA</code> from <code>namespaceA</code> and a <code>ClassB</code> from
    <code>namespaceB</code>, this could be problematic. In Java you can just import the specific class you want.
</p>

<h4>Is there no way around this?</h4>

<p>
    Well actually, there is. You can use <code>ClassA</code> from <code>namespaceA</code> directly without the using
    statement, if you write it in full each time you use it.
</p>

<pre class="brush: csharp;">
namespaceA.ClassA a : new namespaceA.ClassA();
</pre>

<p>
    But nevertheless this is less compact nor ideal if it is a heavily used class.
</p>

<h4>You said delegates are an advantage in C#. What is this and is there a Java alternative?</h4>

<p>
    Delegates in C# is a mechanism that allows a programmer to use different functions, albeit with the same return type
    and parameter list, in a concise way. First, a delegator function is created which states the return type and
    parameter list. The delegator function, indicated as a parameter, can be used in a normal function. When calling the
    normal function, any function that suffices to the return type and parameter list of the delegator function can be
    supplied.
</p>

<p>
    In Java, real delegates aren’t provided. However, one can create a delegate mechanism with the following snippet of
    code. However, as one can see, this causes difficulties in reading the code (as the names cannot really indicate
    well what the delegated functions do). This does not improve the clarity of the meaning of the code.
</p>

<pre class="brush: java;">
public Interface Delegate {
    public void doSomething(Object... args)
}

public Class myClass {
    public void myMethod(Delegate delegate) {
        // ...
        delegate.doSomething(args);
        // ...
    }

    public static void main(String[] args) {
        // ...
        myClassObject.myMethod(new Delegate() {
            public void doSomething(Object... args) {
                // do something in this method.
            }
        });
        // ...
    }
}
</pre>

<h4>Are there any other mechanisms that provide compactness?</h4>

<p>
    Yes, C# provides another mechanism! It has yet a far more compact syntax for creating a delegate, introduced in C#
    2.0: anonymous methods. C# 3.0 expands this feature with lambda expressions. Lambda expressions are divided into two
    types: statement lambdas and expressions lambdas.
</p>

<h4>I’ve learned a lot about functional programming lately and I think its quite useful in the right circumstances. So
    i’ve been wondering, is functional programming possible in Java or C#?</h4>

<p>
    First of all, let’s talk about Java. Java in itself has no capabilities for functional programming in the language
    itself. Lambda expressions, closures, first-class functions and all the other fancy functional programming
    mechanisms are absent from basic Java versions. Java is, however, planning on introducing lambda expressions in a
    next version of Java.
    The best way to try and do some functional programming in Java is to use one of the third-party functional
    programming libraries to do the heavy lifting. But you will never be able to get rid of the verbosity of Java
    itself, so if you really want clean functional code, Java might not be the best option.
</p>

<p>
    C#, on the other hand has already provided some forms of functional programming like lambda expressions. C# also
    provides strongly typed delegates which can be used to almost the same extent as first-class functions can. However,
    even when C# can technically be used to do functional programming, it will never be as easy to use in this matter as
    a pure functional language and doing a lot of functional programming in C# will also quickly become a hassle.
</p>

<h4>Interesting! Can you elaborate a bit more about this?</h4>

<p>
    Statement lambdas consist of a formal parameter list, followed by the lambda operator ‘=>’ and a code block. Some
    syntactic sugar is missing here. These statements do not have a name, which explains the former ‘anonymous methods’
    terminology. Second, the return type is not formally specified. When using the lambda expression, the compiler is
    able to deduct the return type at runtime. Also, the access modifier is omitted, but as the method is no longer an
    accessible member of the containing class there is no need to describe its accessibility. Similarly a static
    modifier would no longer be necessary. At last, it is also possible to omit parameter types if the compiler is able
    to infer the types. This does not always improves the code as it makes the readability harder. As a guideline,
    consider omitting the types when they are obvious to the reader.
</p>

<p>
    Expression lambdas can make this expressions even less verbose. Expressions with only a single return statement can
    be rewritten without explicitly declaring the return keyword. This could avoid extra brackets.
</p>

<h4>So, what can you do with all these lambdas?</h4>

<p>
    Lambdas are a special type of closures and are used to specify local function-valued arguments in calls to other
    methods, like delegates. They can also be used as expression trees.
</p>

<h4>What are expression trees and how are they related to lambda expressions?</h4>

<p>
    Just like a delegate is an object that enables you to pass around a method, is an expression tree an object that
    enables you to pass around the compiler’s analysis of an expression lambda. So, lambda expressions can be converted
    to expression trees and become objects that represent data that describes the lambda expression, not compiled code.
    This way, we can analyze the lambda at execution time!
</p>

<h4>Can you give a practical application of this?</h4>

<p>
    Expression trees make it possible to analyze the lambda at execution time and use that information to construct, for
    example, a query that you can execute on a database. Consider the following example: you want to find all employees
    with a salary above € 2000 in a remote database. This can be done with the following lambda expression.
</p>

<pre class="brush: csharp;">
employees.Where(
      employee => employee.Salary >= 2000);}
}
</pre>

<p>
    One technique to do this is to send all employee records to the client and create employee objects. Next you create
    a delegate from the lambda and execute the delegate on every <code>Employee</code>. You can imagine that when you
    have a large database with millions of employees, this approach can be very expensive. So this is where expression
    trees come in. The lambda expression is converted to a data object that describes the expression. In this case, it
    can be converted to an SQL query and run at the database. The database can run this query and just send the
    requested employees.
</p>

<h4>But how can the compiler decide to convert a statement lambda to a delegate or to an expression tree?</h4>

<p>
    Good question! A lambda that is converted to a delegate causes the compiler to emit the lambda as a method, and
    generates code which creates a delegate to that method at execution time. A lambda that is converted to an
    expression tree causes the compiler to generate code which creates an instance of <code>LambdaExpression</code>
    object at execution time.
</p>

<p>
    The example above that searched employees with a salary more than € 2000 is a LINQ query and is represented with an
    extension method. The methods which extend the IEnumerable&lt;T&gt; interface take delegate parameters; the methods
    which extend the IQueryable&lt;T&gt; interface take expression tree parameters. The compiler can therefore use the
    type of the collection that is being queried to determine whether to create delegates or expression trees from
    lambdas supplied as arguments.
</p>

<h4>Can you give more detail about LINQ?</h4>

<p>
    LINQ stands for Language Integrated Query and can easily be compared with SQL. However, SQL is a domain-specific
    query language and lacks the full power of a complete programming language like C#. The advantage of SQL is that it
    is much easier to read and understand compared with writing your query expressions with methods. That is why the
    language designers added the query expression syntax to C# 3.0.
    As an example, look at the following LINQ query:
</p>

<pre class="brush: csharp;">
IEnumerable&lt;string&gt; selection =
    from word in Keywords
    where !word.Contains('*')
    select word;
</pre>

<p>
    People who know the basics of SQL will definitely be familiar with this example. When evaluating the query, you
    begin by identifying the collection (described by the from clause), then filter out the unwanted items (with the
    where clause) and finally describe the desired result (with the select clause). As a remark, the reordering of
    statements compared with SQL is due to a more logic execution rather than a gain performance. This ordering is more
    related with the actual execution and IDEs are able to deduct the type of the selected variable, something that can
    help the developer.
</p>

<p>
    The features of LINQ are projecting, filtering, sorting and grouping. Projecting can map the traversed data onto
    other objects or anonymous types. Filtering can be done by defining a boolean statement in the where clause. A
    sorting strategy can be defined in the <code>order by</code> statement. Finally, the grouping statement provides a
    way of dividing your data in a self-defined manner.
</p>

<h4>How does the LINQ mechanism works under the hood? </h4>

<p>
    The C# compiler simply translates query expressions into a series of method calls. For example, the outcome of the
    LINQ example given above would be
</p>

<pre class="brush: csharp;">
IEnumerable&lt;string&gt; selection = Keywords.Where(word => word.Contains('*'));
</pre>

<p>
    The lambda expression is then itself translated by the compiler to emit a method with the body of the lambda, as I
    explained before.
</p>

<h4>If LINQ is not in Java, what can Java oppose to LINQ?</h4>

<p>
    Java has nothing as a LINQ equivalent! Some say LINQ is possibly one of the most distinguishing features between
    Java and C#.
</p>

<h4>You made me curious now! I was wondering if there are some keywords in C# that aren’t in Java? Or the other way
    around?</h4>

<p>
    C# indeed has more keywords than Java. C# has a total of 77 predefined keywords, while Java only uses 60 predefined
    keywords. So there are at least 17 keywords in C# that aren’t in Java. Some have already been discussed, like yield
    and namespace. Some are quite simple: C# has predefined keywords foreach and in, while the behavior of these
    keywords combined, can be created in Java with the normal for keyword. The following lines of code should show how
    that is done. In C# one writes
</p>

<pre class="brush: csharp;">
foreach(House house in housesForSale) {
    // ...
}
</pre>

<p>but in Java </p>

<pre class="brush: java;">
for(House house : housesForSale) {
    // ...
}
</pre>

<p>
    A lot of the C# keywords are dedicated to the data types and access modifiers. C# allows programmers to perform
    arithmetic run-time checks with the checked keyword. This construct in C#, which can be seen in the following lines
    of code, checks whether for instance arithmetic overflow happens.
</p>

<pre class="brush: csharp;">
try
{
    z =  checked((short)(x + y));
}
catch (System.OverflowException e)
{
    System.Console.WriteLine(e.ToString());
}
</pre>

<p>
    Since C# allows implicit and explicit conversions, keywords to help the programmer with these conversions are
    provided.
</p>

<p>
    As already said, Java has less keywords than C# but two of them are quite extraordinary. Java predefines the <code>goto</code>
    and <code>const</code> keywords, even though they have never been used in the language.
</p>

<h4>C# does look like a nice programming language to program in, but does it have features that we can exploit for this
    assignment?</h4>

<p>
    Well, C# offers a feature called dynamic programming. Maybe that is something we could use.
</p>

<h4>What is dynamic programming and how do I use it in C#?</h4>

<p>
    If you have an object of some class, you can only use those methods that are defined in that class. That is because
    you statically typed that variable to be that kind of type. The compiler also checks this at compile time. But what
    if you have some object that you don’t know its type at compile time, but only at runtime? It is here where dynamic
    programming comes in. At compile time, it lets the compiler skip verifying and binding and these will instead be
    resolved at execution time.
</p>

<p>
    Dynamic programming was added in C# 4.0 and is very straightforward to use. Instead of declaring type of a variable,
    you just declare it as <code>dynamic</code>. Then you just call methods as you would with a statically typed
    variable. You can even call an undefined method as long as the syntax is valid, because the compiler will not check
    this.
</p>

<h4>What about dynamic programming in Java? Is this possible?</h4>

<p>
    Unfortunately, Java does not offer a <code>dynamic</code> type like C#. You can use reflection, but this is not
    entirely the same.
</p>

<h4>Can you tell me something about the type systems of those two languages?</h4>

<p>
    Well, the main difference between the type system in C# and Java, is that in C# every primitive type inherits from
    one single root <code>object</code> type. We say that C# has a unified type system. This is not the case for Java,
    because several primitive types are not objects like an <code>int</code>.
</p>

<h4>Does C# allow multithreading? I think that we could use multithreading for our assignment. </h4>

<p>
    Indeed, in these times of multicore processors, multithreading cannot be neglected. As it is neither the case for
    Java, nor is it for C#. Using threads in one process enables you to perform concurrent processing and share
    resources of the application. Hower one has to be careful with the latter, because sharing resources among threads
    can also introduce race conditions.
</p>

<p>
    Lets first start with Java. There are two ways of creating a thread. You can implement the Runnable interface and
    then you have to implement the <code>public void run()</code> method. You can also extend the <code>Thread</code>
    class and then you have to overwrite the <code>public void run()</code> method. Afterwards one can call the <code>start()</code>
    method on the thread.
</p>

<p>
    In C#, you can create a thread by instantiating a <code>Thread</code> object with a method as parameter. Afterward
    you call the <code>Start()</code> method on that thread. So there isn’t really a big difference between the way you
    implement a basic thread in Java or C# like you can see in the example below. In Java:
</p>

<pre class="brush: java;">
class ThreadTest extends Thread {
	public void run() {
		for (int i = 0; i &lt; 1000; i++) {
			System.out.print("y");
		}
	}

	public static void main(String[] args) {
		ThreadTest t = new ThreadTest();
		t.start();
		for (int i = 0; i &lt; 1000; i++) {
			System.out.print("x");
		}
	}

}
</pre>

<p>and in C#</p>

<pre class="brush: csharp;">
using System;
using System.Threading;

class ThreadTest{
	public static void WriteY (){
		for (int i = 0; i &lt; 1000; i++){
			Console.Write ("y");
		}
	}

	public static void Main (){
		Thread t = new Thread (WriteY);
		t.Start ();
		for (int i = 0; i &lt; 1000; i++){
			Console.Write ("x");
		}
	}
}
</pre>

<h4>To be honest, I don’t like working so low-level with threads. Isn’t there a better way?</h4>

<p>
    Yes, there is! Indeed, the previous way of creating a multithreaded process in C# is very low level and also
    introduces two limitations. First of all, it is easy to give data to a thread, but more difficult to extract data
    from a thread when it is finished. You have to use a shared field. When something happens, like an exception that is
    thrown, this gets more complicated to handle properly. Secondly, when a thread finishes, you can’t tell that thread
    to start something new.
</p>

<p>
    C#, starting from version 4.0, has come up with an answer to that: the <code>Task</code>. It is a high-level
    abstraction of a concurrent operation that can be run in a thread, but that doesn’t have to be the case. Let’s get
    your hands dirty with the following code to create a <code>Task</code> in C#.
</p>

<pre class="brush: csharp;">
using System;
using System.Threading.Tasks;

class TaskTest
{
	static void Main ()
	{
		Task&lt;int&gt; task = Task.Factory.StartNew (() => {
            Console.WriteLine ("Foo");
            return 5;
        });
        Console.WriteLine(task.Result);
    }
}
</pre>

<p>
    The example incorporates the benefit of using a <code>Task</code> when having a return value. The last call to
    <code>Console.WriteLine</code> will block until the task has finished and returned a result.
</p>

<h4>Is there an equivalent in Java for this?</h4>

<p>
    As of Java 7, the language will include a Fork/Join mechanism. It is not the same as the Task in C#, but the
    Fork/Join mechanism should ease the use of multithreaded programs.
</p>

<h4>Are there any more specific advantages in C# compared with Java?</h4>

<p>
    Yes, as a more advanced topic, C# has a better generics system than Java. Where Java uses type erasure behind the
    scenes, C# stores the type. Under the hood, this means that a Java program needs to cast whenever an element is
    retrieved from a List. In C#, such a cast is not needed. Functional programming is a feature that can be used in C#.
    In Java, the only way to do some functional programming is by using reflection. Of course, there is also a way to
    use reflection in C#. Also, there is a way to use interoperability in C#. Again, in Java, this is not possible.
</p>

<p>
    What distinguishes C# from Java even more, is a feature called Language Integrated Query (LINQ). LINQ extends C# by
    making it possible to conveniently process data from arrays, enumerable classes, XML documents, relational databases
    and third party data sources. There is nothing like LINQ in Java.
</p>

<h4>Is there also a difference between C# and Java when it comes to generics?</h4>

<p>
    As previously stated, the main difference between generics in Java and in C# is the fact that C# retains type
    specific information all throughout the compilation process and that the compiled code still has type information
    available. In Java generics, the concept of type erasure is used. This means that type information is erased during
    compilation. All generically typed objects are cast to the Object type at compile time thusly removing the generic
    type information. This means that once the code is compiled, the generic type information is gone and cannot be used
    at runtime to perform type specific operations. Java reflection at runtime can only access the Object type’s members
    or you need to cast the object back to the original type at runtime which isn’t type safe. The only way this can
    happen securely is because the Java type checker validates whether the generic code is correctly typed before
    compilation.
</p>

<p>
    In C#, preserving the type information throughout the compilation process allows for a more secure generic type
    system while not having the performance penalty of having to cast all the time.
</p>

<h4>So why did the Java guys choose to do it this way?</h4>

<p>
    One of the main reasons behind this design choice is the argument of backward compatibility. Because the generic
    type
    information is removed at compile time an ArrayList&lt;Person&gt; just becomes a ArrayList of Objects. This way the
    generated code remains compatible with earlier versions of Java which didn’t have any form of generics yet (for
    example
    the non-generic ArrayList instances). It may be useful to note that from a language perspective, there aren’t any
    problems with Java-generics. It is not particularly different than generics in C#, but the way they are handled by
    there
    respective “virtual machines” is different.
</p>

<h4>So you are saying that C# is not backward compatible in terms of generics?</h4>

<p>
    Not completely, no. They did introduce generics a little bit earlier in their timeline than Java did, but if you go
    back to C# before version 2.0 you will notice that you have to convert your List&lt;Something&gt; back to simple
    List objects to work with them.
</p>

<p>
    The reason they chose to abandon this backwards compatibility, is a matter of performance.
    By keeping the generic type information throughout the compilation process, the C# JIT compiler is able to create
    specific code tailored to the generic parameter. It is af if you wrote a complete specific class representing a list
    of Somethings called <code>ListOfSomethings</code>. This avoids the need to cast and therefore, the performance
    penalty for casting. And as stated before, it also has the added benefit of being able to use reflection at runtime
    to gather specific information about Something-objects.
</p>

<h4>I have heard about this thing called interoperability. What does this mean actually?</h4>

<p>
    Interoperability is a pretty broad term. Technically, it is the ability of a component for being able to work
    together with other components now and in the future (and sometimes even with components from the past which is
    called backwards-compatibility). This, again, is a pretty vague statement. In programming it is also often mentioned
    as a metric for how well a certain programming language allows working with other programming languages.
</p>

<h4>Does C# have a better interoperability score than Java?</h4>

<p>
    Well, it is hard to compare the two languages based on this measure because nowadays there are a lot of different
    projects meant for making both languages more interoperable.
    But if we look at the languages themselves, it is safe to say that both languages have made efforts to be used by
    other languages and to use other languages themselves.
</p>

<p>
    Java and Scala can be used interchangeably when programming in either language, while C# has the advantage of being
    able to use C++ components.
</p>

<p>
    I would say though, that C# does score higher on the interoperability mark when you consider the possibilities for
    calling and invoking windows specific constructs, like COM objects or general Win32 API calls. C# was primarily
    meant for Windows Platforms, so it is understandable that it supports native windows construct a bit better than
    Java (which was designed with a platform independent philosophy) does. The Mono platform, created to bring C# to
    other platforms was never able to provide the same interoperability as C# originally had.
</p>

<p>
    Interoperability is also a measure between two entities. For example, you can gauge the interoperability between
    Java and another language. It is not really a metric you can measure on its own.
</p>

<h4>Ok, so how is the interoperability between Java and C# then? Can they be used interchangeably?</h4>

<p>
    That is a really interesting question. In itself it is not possible to use the two languages interchangeably because
    they both run in their own virtualised environment (JVM vs. CLR).
    So one language or the other is always going to need a certain bridge or adapter or something to understand notions
    from the other language.
</p>

<p>
    There are, however, a few interesting projects that try to bridge the two languages and offer a mechanism from using
    concepts from both languages at the same time. For example, there exists a project called jni4net, which offers a
    bridge between Java and .NET with which you can program in both languages and call methods and libraries from the
    other language.
    There is also a project called IKVM.NET which is basically a JVM implemented in .NET with .NET implementations of
    the Java class libraries and tools for making interoperability easier.
</p>

<p>
    And these are just a few of the projects out there in the wild. People will always be interested in merging and
    combining different languages or reusing code from different languages, so you can expect that projects for bridging
    the interoperability gap will always be in existence.
</p>

<h4>What are all the steps between writing and executing a Java or C# file?</h4>

<p>
    Developers in Java must have the Java SDK, or shortened Java Development Kit (JDK). This consists of the Java
    Runtime Environment (JRE) and some development tools like a compiler (<code>javac</code>) and a documentation
    generator (<code>javadoc</code>). There are two important JDKs available: openJDK and Oracle JDK. Technically, 99%
    of both JDKs overlap so there is not so much of a difference apart from licensing. The first comes with a GNU GPL
    version 2 license - free and open-source - while the latter has a custom license.
</p>

<p>
    As already discussed, Java excels in its portability. It is designed to execute on the Java platform via the JRE.
    The platform includes the Java Virtual Machine (JVM) and a common set of libraries, a sufficient requirement to
    execute Java programs. The compiler produces Java bytecode and is is loaded by the Java runtime. This bytecode is
    either interpreted directly or compiled to machine instructions and then executed.
</p>

<p>
    C# depends on the .NET framework from Microsoft if we discard the Mono project. The framework is only supported for
    Windows machines but can handle more that just C#. Languages like VB.NET, C++ or J# have a compiler that transforms
    the source code to the common intermediate language (CIL). Just like Java, C# programs are not compiled to machine
    code but to this intermediate language. A second compilation step occurs, generally at execution time, converting
    the CIL to machine code. The specification for the CIL and the runtime is contained within an international standard
    known as the Common Language Infrastructure (CLI). The execution of the CIL code happens on a runtime engine,
    Virtual Execution System (VES), which can be compared to the JVM. This engine provides some abstraction of the
    underlying machine and is more casually referred to as the runtime.
</p>

<p>
    The second compilation from CLI to CPU instructions happens at execution-time. The CIL can also be interpreted
    rather than compiled, similar to the way many scripting languages work.
</p>

<h4>Is garbage collection supported in both languages?</h4>

<p>
    Yes, the JVM and runtime both handle this. The JVM searches the Java heap for unused objects and reclaims the used
    space. Before doing so, the garbage collector thread finalizes the object and gives the opportunity to do some
    cleanup. The finalize method can be called at any moment in time when an object becomes eligible for garbage
    collection. The C# approach contains a lot of similarities. Garbage collection uses a generational, compacting,
    mark-and-sweep based algorithm. Generational, because objects that have lived for only a short period will be
    cleaned up sooner. Compacting, because after deletion it compacts together the objects that remain so that there is
    no dirty, unused space in the memory.
</p>

<hr class="bs-docs-separator">
<h2>Movie</h2>
<p>To conclude, a funny trailer about a father who is all about the .NET platform. His son discovers Java, but his
    father won't let this happen...</p>

<iframe width="100%" height="350" src="http://www.youtube-nocookie.com/embed/9QFK1cLhytY?rel=0" frameborder="0"
        allowfullscreen></iframe>

<hr class="bs-docs-separator">
<h2>References</h2>
<!-- Eerst boeken, daarna websites -->
<!--<h3>References</h3> -->
	<ul>
	    <li>Albahari, J., &amp; Albahari, B. (26 Juni 2012). <em>C# 5.0 in a Nutshell: The Definitive Reference</em> (5th ed.). O"Reilly Media</li>
	    <li>Griffiths, I. (5 November 2012). <em>Programming C# 5.0</em>. O"Reilly Media.</li>
	    <li>Michaelis, M., &amp; Lippert, E. (2012). <em>Essential C# 5.0</em> (4th ed.). Addison-Wesley Professional.</li>
	    <li>Sebesta, R. W. (16 January 2012). <em> Concepts of Programming Languages </em> (10th ed.). Addison-Wesley.</li>
	    <li>Skeet, J. (22 November 2010). <em>C# in Depth</em> (2nd ed.). Manning Publications.</li>

	    <li><em>Anders Hejlsberg.</em> (n.d.). Retrieved on November 11, 2012, on <a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">http://en.wikipedia.org/wiki/Anders_Hejlsberg</a>.</li>
	    <li><em>An introduction to Operator Overloading in C#.</em> DaveyM69. Posted on September 29, 2008. Retrieved on November 14, 2012, on <a href="http://www.codeproject.com/Articles/28974/An-Introduction-to-Operator-Overloading-in-C">http://www.codeproject.com/Articles/28974/An-Introduction-to-Operator-Overloading-in-C</a>.</li>
	    <li><em>Are primitives different in Java and C#?</em> pst. Posted on October 21, 2009. Retrieved on November 4, 2012, on <a href="http://stackoverflow.com/questions/1597999/are-primitives-different-in-java-and-c">http://stackoverflow.com/questions/1597999/are-primitives-different-in-java-and-c</a>.</li>
	    <li><em>Boxing and Unboxing.</em> (n.d.). Retrieved on November 9, 2012, on <a href="http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx">http://msdn.microsoft.com/en-us/library/yz2be5wk.aspx</a>.</li>
	    <li><em>C# (the programming language).</em> (n.d.). Retrieved on November 13, 2012, on <a href="http://en.wikipedia.org/wiki/C_Sharp_">http://en.wikipedia.org/wiki/C_Sharp_</a>(programming_language).</li>
	    <li><em>C# access modifiers.</em> (n.d.). Retrieved October 31, 2012, on <a href="http://msdn.microsoft.com/en-us/library/ms173121%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/ms173121%28v=vs.80%29.aspx</a>.</li>
	    <li><em>C# compact getters and setters.</em> Ry99. Published on May 9, 2009. Retrieved on November 1, 2012, on <a href="http://forums.asp.net/t/1191140.aspx">http://forums.asp.net/t/1191140.aspx</a>.</li>
	    <li><em>C# extension methods.</em> (n.d.). Retrieved on November 8, 2012, on <a href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx">http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx</a>.</li>
	    <li><em>C# extension methods code example.</em> (n.d.). Retrieved on November 8, 2012, on <a href="http://csharp.net-tutorials.com/csharp-3.0/extension-methods/#.UJuXVOMSXoQ">http://csharp.net-tutorials.com/csharp-3.0/extension-methods/#.UJuXVOMSXoQ</a>.</li>
	    <li><em>C# generator methods.</em> (n.d.). Retrieved on November 8, 2012, on <a href="http://en.wikipedia.org/wiki/Generator_">http://en.wikipedia.org/wiki/Generator_</a>(computer_programming).</li>
	    <li><em>C# generics.</em> (n.d.). Retrieved October 31, 2012, on <a href="http://msdn.microsoft.com/en-us/library/512aeb7t%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/512aeb7t%28v=vs.80%29.aspx</a>.</li>
	    <li><em>C# interoperability.</em> (n.d.). Retrieved on October 31, 2012, on <a href="http://msdn.microsoft.com/en-us/library/ms173184%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/ms173184%28v=vs.80%29.aspx</a>.</li>
	    <li><em>C# keywords.</em> (n.d.). Retrieved on November 15, 2012, on <a href="http://msdn.microsoft.com/en-us/library/x53a06bb">http://msdn.microsoft.com/en-us/library/x53a06bb</a>(v=vs.71).aspx.</li>
	    <li><em>C# optional parameters.</em> (n.d.). Retrieved November 8, 2012, on <a href="http://msdn.microsoft.com/en-us/library/dd264739.aspx">http://msdn.microsoft.com/en-us/library/dd264739.aspx</a>.</li>
	    <li><em>C# delegates.</em> (n.d.). Retrieved on November 1, 2012, on <a href="http://msdn.microsoft.com/en-us/library/aa288459">http://msdn.microsoft.com/en-us/library/aa288459</a>(v=vs.71).aspx.</li>
	    <li><em>C# properties.</em> (n.d.). Retrieved on November 1, 2012, on <a href="http://msdn.microsoft.com/en-us/library/aa288470">http://msdn.microsoft.com/en-us/library/aa288470</a>(v=vs.71).aspx.</li>
	    <li><em>C# reflection.</em> (n.d.). Retrieved October 31, 2012, on <a href="http://msdn.microsoft.com/en-us/library/ms173183%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/ms173183%28v=vs.80%29.aspx</a>.</li>
	    <li><em>C# Station Tutorial.</em> Joe Mayo. Posted on December 18, 2004. Retrieved on November 14, 2012, on <a href="http://www.csharp-station.com/Tutorials/Lesson18.aspx">http://www.csharp-station.com/Tutorials/Lesson18.aspx</a>.</li>
	    <li><em>C# vs Java: instance initializers.</em> Imsasu. Posted on March 28, 2009. Retrieved on November 6, 2012, on <a href="http://stackoverflow.com/questions/692735/c-sharp-equivalent-of-java-instance-initializer">http://stackoverflow.com/questions/692735/c-sharp-equivalent-of-java-instance-initializer</a>.</li>
	    <li><em>Comparison of C# and Java.</em> (n.d.). Retrieved on October 31, 2012, on <a href="http://en.wikipedia.org/wiki/Comparison_of_Java_and_C_Sharp">http://en.wikipedia.org/wiki/Comparison_of_Java_and_C_Sharp</a>.</li>
	    <li><em>Difference between generics in Java and in C#.</em> Orion Edwards. Posted on August 28, 2008. Retrieved on October 31, 2012, on <a href="http://stackoverflow.com/questions/31693/what-are-the-differences-between-generics-in-c-sharp-and-java-and-templates-i">http://stackoverflow.com/questions/31693/what-are-the-differences-between-generics-in-c-sharp-and-java-and-templates-i</a>.</li>
	    <li><em>Difference between String and string in C#.</em> Derek Park. Posted on May 23, 2010. Retrieved on November 14, 2012, on <a href="http://stackoverflow.com/questions/7074/what-is-the-difference-between-string-and-string">http://stackoverflow.com/questions/7074/what-is-the-difference-between-string-and-string</a>.</li>
	    <li><em>Dynamic Programming in C#.</em> Paulo Morgado. Posted on April 18, 2010. Retrieved on November 15, 2012, on <a href="http://www.codeproject.com/Articles/73856/C-4-0-Dynamic-Programming">http://www.codeproject.com/Articles/73856/C-4-0-Dynamic-Programming</a>.</li>
	    <li><em>For what C# is used.</em> (n.d.). Retrieved on November 11, 2012, on <a href="http://wiki.tcl.tk/6188">http://wiki.tcl.tk/6188</a>.</li>
	    <li><em>How close are Java and C#?</em> herenvardo. Posted on April 12, 2010. Retrieved on November 15, 2012, on <a href="http://stackoverflow.com/questions/2625520/java-and-c-how-close-are-they">http://stackoverflow.com/questions/2625520/java-and-c-how-close-are-they</a>.</li>
	    <li><em>How does string override the + operator?</em> Lion. Posted on July 10, 2012. Retrieved on November 15, 2012, on <a href="http://stackoverflow.com/questions/11408427/how-does-the-string-class-override-the-operator">http://stackoverflow.com/questions/11408427/how-does-the-string-class-override-the-operator</a>.</li>
	    <li><em>IKVM.</em> (n.d.). Retrieved on November 15, 2012, on <a href="http://www.ikvm.net/">http://www.ikvm.net/</a>.</li>
	    <li><em>Introduction to C#.</em> Manindu Wijewickrama. Posted on September 24, 2012. Retrieved on November 15, 2012, on <a href="http://dotnetrepublic.blogspot.be/2012/09/introduction-to-c-programming-language.html">http://dotnetrepublic.blogspot.be/2012/09/introduction-to-c-programming-language.html</a>.</li>
	    <li><em>Java access modifiers.</em> (n.d.). Retrieved on October 31, 2012, on <a href="https://en.wikibooks.org/wiki/Java_Programming/Scope">https://en.wikibooks.org/wiki/Java_Programming/Scope</a>.</li>
	    <li><em>Java and C#</em> Brian Shearing. Posted on September 13, 2012. Retrieved on November 15, 2012, on <a href="http://www.docstoc.com/docs/129487585/Java-and-C">http://www.docstoc.com/docs/129487585/Java-and-C</a>.</li>
	    <li><em>Java and C# comparison.</em> (n.d). Retrieved on November 14, 2012, on <a href="http://www.harding.edu/fmccown/java_csharp_comparison.html">http://www.harding.edu/fmccown/java_csharp_comparison.html</a>.</li>
	    <li><em>Java Development Kit.</em> (n.d.). Retrieved on November 13, 2012, on <a href="http://nl.wikipedia.org/wiki/Java_Development_Kit">http://nl.wikipedia.org/wiki/Java_Development_Kit</a>.</li>
	    <li><em>Java equivalent for LINQ.</em> AgileJon. Posted on August 1, 2009. Retrieved on October 31, 2012, on <a href="http://stackoverflow.com/questions/1217228/what-is-the-java-equivalent-for-linq">http://stackoverflow.com/questions/1217228/what-is-the-java-equivalent-for-linq</a>.</li>
	    <li><em>Java generics (more detailed: type erasure).</em> (n.d.). Retrieved on October 31, 2012, on <a href="http://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">http://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure</a>.</li>
	    <li><em>Java keywords.</em> (n.d.). Retrieved on November 15, 2012, on <a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">http://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a>.</li>
	    <li><em>Java optional parameters.</em> Vitalii Fedorenko. Posted on October 21, 2009. Retrieved on November 8, 2012, on <a href="http://stackoverflow.com/questions/965690/java-optional-parameters">http://stackoverflow.com/questions/965690/java-optional-parameters</a>.</li>
	    <li><em>Java reflection.</em> (n.d.). Retrieved on October 31, 2012, on <a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">http://docs.oracle.com/javase/tutorial/reflect/index.html</a>.</li>
	    <li><em>Java theory and practice: Generics gotchas.</em> Brian Goetz. Posted on January 25, 2005. Retrieved on November 4, 2012, on  <a href="https://www.ibm.com/developerworks/java/library/j-jtp01255/index.html">https://www.ibm.com/developerworks/java/library/j-jtp01255/index.html</a>.</li>
	    <li><em>Java Threads tutorial.</em> (n.d.). Retrieved on November 15, 2012, on <a href="http://www.javabeginner.com/learn-java/java-threads-tutorial">http://www.javabeginner.com/learn-java/java-threads-tutorial</a>.</li>
	    <li><em>Java vs. C#, enums.</em> Dare Obasanjo. Retrieved on November 6, 2012, on <a href="http://www.25hoursaday.com/CsharpVsJava.html#enums">http://www.25hoursaday.com/CsharpVsJava.html#enums</a>.</li>
	    <li><em>Java"s Checked exceptions.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://www.javapractices.com/topic/TopicAction.do?Id=129">http://www.javapractices.com/topic/TopicAction.do?Id=129</a>.</li>
	    <li><em>Java"s Fork/Join.</em> (n.d.). Retrieved on November 17, 2012, on <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a>.</li>
	    <li><em>jni4net</em> (n.d.). Retrieved on November 15, 2012, on <a href="http://jni4net.sourceforge.net/">http://jni4net.sourceforge.net/</a>.</li>
	    <li><em>Late-bound (dynamic) type.</em> (n.d.). Retrieved on November 15, 2012, on <a href="http://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java#Late-bound_.28dynamic.29_type">http://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java#Late-bound_.28dynamic.29_type</a>.</li>
	    <li><em>LINQ.</em> (n.d). Retrieved on October 31, 2012, on <a href="http://en.wikipedia.org/wiki/LINQ">http://en.wikipedia.org/wiki/LINQ</a>.</li>
	    <li><em>Namespaces in C# vs. imports in Java.</em> Jon Skeet. Posted on September 22, 2010. Retrieved on November 9, 2012, on <a href="http://stackoverflow.com/questions/3767910/namespaces-in-c-sharp-vs-imports-in-java-and-python">http://stackoverflow.com/questions/3767910/namespaces-in-c-sharp-vs-imports-in-java-and-python</a>.</li>
	    <li><em>New features in C#.</em> (n.d.). Retreived on November 12, 2012, on <a href="http://www.kunal-chowdhury.com/2012/07/evolution-of-c-10-50-what-are-new.html">http://www.kunal-chowdhury.com/2012/07/evolution-of-c-10-50-what-are-new.html</a>.</li>
	    <li><em>No properties in Java.</em> Scott Stanchfield. Posted on September 16, 2008. Retrieved on Novemer 1, 2012, on <a href="http://stackoverflow.com/questions/70471/no-properties-in-java">http://stackoverflow.com/questions/70471/no-properties-in-java</a>.</li>
	    <li><em>Oracle JDK vs. Open JDK.</em> Pascal Thivent. Posted on December 29, 2009. Retrieved on November 13, 2012, on <a href="http://stackoverflow.com/questions/1977238/why-should-i-use-the-oracle-jdk-over-the-openjdk-or-vice-versa">http://stackoverflow.com/questions/1977238/why-should-i-use-the-oracle-jdk-over-the-openjdk-or-vice-versa</a>.</li>
	    <li><em>Parameters in Java</em> erlando. Posted on January 26, 2011. Retrieved on November 13, 2012, on <a href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference">http://stackoverflow.com/questions/40480/is-java-pass-by-reference</a>.</li>
	    <li><em>Price of Microsoft"s Visual Studio.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://www.microsoftstore.com/store/mseea/nl_NL/pdp/productID.255904100">http://www.microsoftstore.com/store/mseea/nl_NL/pdp/productID.255904100</a>.</li>
	    <li><em>Soft References in Java.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ref/SoftReference.html">http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ref/SoftReference.html</a>.</li>
	    <li><em>Phantom references in Java.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ref/PhantomReference.html">http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/ref/PhantomReference.html</a>.</li>
	    <li><em>References in Java.</em> Roedy Green. Retrieved on November 6, 2012, on <a href="http://mindprod.com/jgloss/phantom.html">http://mindprod.com/jgloss/phantom.html</a>.</li>
	    <li><em>Static imports, according to Java.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/static-import.html">http://docs.oracle.com/javase/1.5.0/docs/guide/language/static-import.html</a>.</li>
	    <li><em>Static imports are not possible in C#.</em> Jon Skeet. Posted on September 14, 2009. Retrieved on November 6, 2012, on <a href="http://stackoverflow.com/questions/1423809/how-to-import-a-static-class-in-c">http://stackoverflow.com/questions/1423809/how-to-import-a-static-class-in-c</a>.</li>
	    <li><em>The difference between properties and fields.</em> Cory. Posted on November 18, 2008. Retrieved on November 1, 2012, on <a href="http://stackoverflow.com/questions/295104/what-is-the-difference-between-a-field-and-a-property-in-c">http://stackoverflow.com/questions/295104/what-is-the-difference-between-a-field-and-a-property-in-c</a>.</li>
	    <li><em>The Mono project.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://www.mono-project.com/Main_Page">http://www.mono-project.com/Main_Page</a>.</li>
	    <li><em>The Mono project on Wikipedia.</em> (n.d.). Retrieved on November 6, 2012, on <a href="http://en.wikipedia.org/wiki/Mono_">http://en.wikipedia.org/wiki/Mono_</a>(software).</li>
	    <li><em>Why C# is better than Java.</em> Yam Marcovic. Posted on December 17, 2011. Retrieved on October 31, 2012, on <a href="http://programmers.stackexchange.com/questions/125712/for-what-reasons-should-i-choose-c-over-java-and-c">http://programmers.stackexchange.com/questions/125712/for-what-reasons-should-i-choose-c-over-java-and-c</a>.</li>
	    <li><em>Why Java does not offer Operator Overloading.</em> paercebal. Posted on September 27, 2008. Retrieved on November 14, 2012, on <a href="http://stackoverflow.com/questions/77718/why-doesnt-java-offer-operator-overloading">http://stackoverflow.com/questions/77718/why-doesnt-java-offer-operator-overloading</a>.</li>
	    <li><em>Why Java is not supporting operator overloading.</em> Trims. Posted on March 4, 2012. Retrieved on November 14, 2012, on <a href="http://wiki.answers.com/Q/Why_java_not_support_operator_overloading">http://wiki.answers.com/Q/Why_java_not_support_operator_overloading</a>.</li>
	</ul>
</div>
<div id="push"></div>
</div>

<div id="footer">
    <div class="container">
        <p class="muted credit">By Tim Ameye, Kristof Coninx, Sander Van Loock and Koen Wellens.</p>
    </div>
</div>

<script src="js/shCore.js"></script>
<script src="js/shBrushCSharp.js"></script>
<script src="js/shBrushJava.js"></script>
<script>
    SyntaxHighlighter.all();
</script>

</body>
</html>
